<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="darksimplicity">
  <meta name="generator" content="Hugo 0.20.2" />
  
  
  <base href="https://jeqo.github.io/">
  <title>Tracing Kafka applications</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.020/css/hack-extended.min.css">
  <link rel="stylesheet" href="/css/style.min.css">  
  <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/images/apple-touch-icon.png" />
</head>
<body>
  <div class="wrap">
    <div class="navbar">
        <ul class="navbar-list" style="float:right">
          <li class="navbar-item">
              <a class="navbar-link" href="https://jeqo.github.io/post/">Blog</a>
          </li><li class="navbar-item">
              <a class="navbar-link" href="https://jeqo.github.io/talk/">Talks</a>
          </li>
          
    </div>
    <div class="header">
      <span style="font-size: 34px;">
        <a href="https://jeqo.github.io/">@jeqo</a>
      </span>
      <span style="font-size:12px;">&nbsp;&nbsp;|&nbsp;&nbsp;<i>back-end, integration, devops, etc.</i> </span>
    </div>

<div class="empty">&nbsp;</div>
  <div class="post-title">
    <a class="post-title-link" href="https://jeqo.github.io/post/2017-09-28-kafka-opentracing/">Tracing Kafka applications</a>
  </div>
      <div class="tags">tags:</br>
        <a class="tag-link" href="/tags/kafka">kafka </a><a class="tag-link" href="/tags/tracing">tracing </a>
    </div>
    <div class="content-full">

<p>Tracing is one of the hardest time in integration or microservice development:
knowing how a request impact your different components, and if your components
have behave as expected.</p>

<p>This could be fairly easy if we have monolith where we have one database and
with some queries or checking one log file you can validate everything went
well.</p>

<p>Once you introduce distributed components and asynchronous communication
this starts to get more complex and tedious.</p>

<p>OpenTracing (<a href="http://opentracing.io/">http://opentracing.io/</a>) offers a way to solve this bringing a
vendor neutral API to be able to create <code>spans</code> that represent the meaningful
tasks that form part of a <code>trace</code>.</p>

<h1 id="use-case">Use-Case</h1>

<p>In this post we will see how to instrument Java applications that communicates
using Apache Kafka as Event Log, and how visualize traces and analyze latency.</p>

<p>The scenario will be a simple Hello World Producer/Consumer. The producer
side will send a &ldquo;greeting&rdquo; event to &ldquo;greetings-topic&rdquo;, and the consumer
side will poll events and print out to console.</p>

<h1 id="technologies">Technologies</h1>

<ul>
<li><p><strong>Dropwizard</strong>: Framework to run Web Services.</p></li>

<li><p><strong>Apache Kafka</strong>: Event Log.</p></li>

<li><p><strong>OpenTracing and Jaeger</strong>: API and instrumentation for distributed tracing.</p></li>
</ul>

<h1 id="implementation">Implementation</h1>

<p>Let&rsquo;s assume we have a simple application that produce <code>greetings</code> events
and another application that consumes and print those events.</p>

<p>To execute this applications let&rsquo;s first start a local version of Kafka:</p>

<h2 id="install-and-run-kafka">Install and Run Kafka</h2>

<p>First, execute the script to install Kafka:</p>

<pre><code class="language-bash">cd kafka/
./install-kafka.sh
</code></pre>

<p>Once it is installed, start Zookeeper and then one Kafka broker:</p>

<pre><code class="language-bash">./start-zookeeper.sh
...
[2017-09-27 22:09:26,634] INFO binding to port 0.0.0.0/0.0.0.0:2181 (org.apache.zookeeper.server.NIOServerCnxnFactory)
...

</code></pre>

<pre><code class="language-bash">./start-broker.sh
...
[2017-09-27 22:09:33,814] INFO Registered broker 0 at path /brokers/ids/0 with addresses: EndPoint(jeqo-Oryx-Pro,9092,ListenerName(PLAINTEXT),PLAINTEXT) (kafka.utils.ZkUtils)
...
[2017-09-27 22:09:33,817] INFO [Kafka Server 0], started (kafka.server.KafkaServer)
...
</code></pre>

<h2 id="run-applications">Run Applications</h2>

<h3 id="start-producer-side">Start Producer Side</h3>

<p>To get started, let&rsquo;s start the producer side and test it.</p>

<p>Build the whole project: <code>./mvnw clean install</code></p>

<p>And start the producer application:</p>

<pre><code class="language-bash">cd hello-world-producer/
java -jar target/hello-world-producer.jar server config.yml
</code></pre>

<p>This will start a web server listening on port 8080.</p>

<p>We have a resource listening on context <code>/hello</code> and an operation
<code>GET /hello/{name}</code> that will call the <code>KafkaHelloWorldProducer</code>
that sends the record to Kafka.</p>

<p>Once the applications is started, we can call the operation with curl:</p>

<pre><code class="language-bash">curl -XGET http://localhost:8080/hello/jeqo
done.
</code></pre>

<h3 id="start-consumer-side">Start Consumer Side</h3>

<p>Once producer side is started and running, we can start consumer side
to print out the events:</p>

<pre><code class="language-bash">java -jar target/hello-world-consumer.jar server config.yml
...
Hi jeqo
...
</code></pre>

<p>So far these are common Kafka producer/consumer applications.</p>

<blockquote>
<p>Source code on branch: steps/step-01</p>
</blockquote>

<h2 id="opentracing-instrumentation">OpenTracing Instrumentation</h2>

<p>OpenTracing has enrich its integration throw projects that we can
contribute: <a href="https://github.com/opentracing-contrib/">https://github.com/opentracing-contrib/</a></p>

<p>We will follow the next steps:</p>

<ol>
<li><p>Instrument Dropwizard</p></li>

<li><p>Instrument Kafka Producer</p></li>

<li><p>Instrument Kafka Consumer</p></li>

<li><p>Test complete Traces</p></li>
</ol>

<h3 id="instrument-dropwizard">Instrument Dropwizard</h3>

<p>We are following this step to have a complete view since request is
received.</p>

<p>Firsts let&rsquo;s add Maven dependencies:</p>

<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;io.opentracing&lt;/groupId&gt;
            &lt;artifactId&gt;opentracing-api&lt;/artifactId&gt;
            &lt;version&gt;0.30.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.opentracing.contrib.dropwizard&lt;/groupId&gt;
            &lt;artifactId&gt;dropwizard-opentracing&lt;/artifactId&gt;
            &lt;version&gt;0.2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.uber.jaeger&lt;/groupId&gt;
            &lt;artifactId&gt;jaeger-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>

<p>First, the <code>opentracing-api</code> dependency.</p>

<p>Then <code>dropwizard-opentracing</code> that is the instrumentation for
DropWizard applications
that handles traces for all of your JAX-RS resource&rsquo;s operations by default.</p>

<p>And <code>jaeger-core</code> that implements OpenTracing API and
adds the Jaeger Java Client to connect to Jaeger Agent.</p>

<p>Then, we need to instantiate and register the Tracer on the Application
class:</p>

<pre><code class="language-java">    final Tracer tracer = //(1)
        new com.uber.jaeger.Configuration(
            getName(),
            new com.uber.jaeger.Configuration.SamplerConfiguration(&quot;const&quot;, 1),
            new com.uber.jaeger.Configuration.ReporterConfiguration(
                true,  // logSpans
                &quot;localhost&quot;,
                6831,
                1000,   // flush interval in milliseconds
                10000)  /*max buffered Spans*/)
            .getTracer();
    GlobalTracer.register(tracer); //(2)
    final DropWizardTracer dropWizardTracer = new DropWizardTracer(tracer); //(3)
    environment.jersey()
        .register(
            new ServerTracingFeature.Builder(dropWizardTracer)
                .withTraceAnnotations()
                .build());
</code></pre>

<p>In the first operation, we are instantiating a <code>Tracer</code> object with
Jaeger. Jaeger Agent should be running on port <code>localhost:6831</code>.</p>

<p>Then we are registering the <code>tracer</code> on the <code>GlobalTracer</code> helper, to
reference it from other layers.</p>

<p>And in the third step, we are integrating the tracer with DropWizard.
We are configuring this integration to only trace operations with
<code>@Trace</code> annotation: <code>.withTraceAnnotations()</code></p>

<p>So, your resource class, should looks like this:</p>

<pre><code class="language-java">  @GET
  @Path(&quot;{name}&quot;)
  @Trace
  public Response sayHi(@PathParam(&quot;name&quot;) final String name) {
    producer.send(name);
    return Response.accepted(&quot;done.&quot;).build();
  }
</code></pre>

<p>Let&rsquo;s install and start Jaeger, in its standalone version:</p>

<pre><code>cd jaeger/
./install-jaeger.sh
</code></pre>

<p>And then:</p>

<pre><code>./start-standalone.sh
</code></pre>

<p>Once it is started, you can go to: <a href="http://localhost:16686/search">http://localhost:16686/search</a></p>

<p>And check its UI.</p>

<p>Now, let&rsquo;s run a first request to check if a trace is created:</p>

<pre><code>curl http://localhost:8080/hello/jorge
</code></pre>

<p>And refresh the Jaeger UI:</p>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/first-trace.png" alt="first trace" /></p>

<blockquote>
<p>Source code on branch: steps/step-02</p>
</blockquote>

<h3 id="instrument-kafka-producer-api">Instrument Kafka Producer API</h3>

<p>Cool! Now we have how long it takes to return a response on the
producer side :)</p>

<p>From here we can start asking:</p>

<p>How long it takes to execute the <code>send</code> operation by the Kafka
Producer? How long it takes to receive metadata from broker?
How long it takes to receive the record on the consumer side?
Did the consumer side receive the message?</p>

<p>This are the question we should be able to solve using OpenTracing.</p>

<p>Now let&rsquo;s add instrumentation for Kafka Clients:</p>

<p>First, let&rsquo;s add another dependency:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.opentracing.contrib&lt;/groupId&gt;
    &lt;artifactId&gt;opentracing-kafka-client&lt;/artifactId&gt;
    &lt;version&gt;0.0.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p><a href="https://github.com/opentracing-contrib/java-kafka-client">https://github.com/opentracing-contrib/java-kafka-client</a></p>

<p>And let&rsquo;s wrap the tracer on a <code>TracingKafkaProducer</code>:</p>

<pre><code class="language-java">    final KafkaProducer&lt;String, String&gt; kafkaProducer =
        new KafkaProducer&lt;&gt;(producerProperties, new StringSerializer(), new StringSerializer());
    final TracingKafkaProducer&lt;String, String&gt; tracingKafkaProducer =
        new TracingKafkaProducer&lt;&gt;(kafkaProducer, tracer);

</code></pre>

<p>The main difference, is that <code>TracingKafkaProducer</code> will inject
tracing context on Kafka Headers (supported since v0.11.0).</p>

<p>That&rsquo;s it, let&rsquo;s redeploy and test again.</p>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/second-traces-not-linked.png" alt="Traces not linked" /></p>

<p>Wait!!! but we only run one request, why do we have 2 traces???</p>

<p>The thing is that to create <code>spans</code> that are related, we need to create
a reference.</p>

<p>How do we do this?</p>

<p>First, we need to obtain the span from the request, and then create an
<code>ActiveSpan</code> that will wrap the execution of Kafka Client. Let&rsquo;s see
how this looks:</p>

<p>Let&rsquo;s go to the resource operation and add a parameter:</p>

<pre><code class="language-java">  public Response sayHi(@Context final Request request,
                        @PathParam(&quot;name&quot;) final String name) {
</code></pre>

<p>Then we can use it to get the span using the DropwizardTracer:</p>

<pre><code class="language-java">@Path(&quot;hello&quot;)
public class HelloWorldResource {
  private final DropWizardTracer dropWizardTracer; //(1)
  private final KafkaHelloWorldProducer producer;

  public HelloWorldResource(final DropWizardTracer dropWizardTracer,
                            final KafkaHelloWorldProducer producer) {
    this.dropWizardTracer = dropWizardTracer;
    this.producer = producer;
  }

  @GET
  @Path(&quot;{name}&quot;)
  @Trace
  public Response sayHi(@Context final Request request,  //(2)
                        @PathParam(&quot;name&quot;) final String name) {
    final Span span = dropWizardTracer.getSpan(request);  //(3)

    try (ActiveSpan activeSpan =
             dropWizardTracer.getTracer()
                 .buildSpan(&quot;sayHi&quot;)
                 .asChildOf(span)
                 .startActive()) {  //(4)
      producer.send(name);
      return Response.accepted(&quot;done.&quot;).build();
    }
  }
}
</code></pre>

<p>First we inject the Tracer, then we get the span from Request,
and finally we create an ActiveSpan that wraps the producer.</p>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/third-traces-together.png" alt="Traces together" /></p>

<p>And if we go to the detail we can get more insight from the execution:</p>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/trace-details.png" alt="Trace details" /></p>

<p>We can get a more deep understanding about the trace execution,
how the callback works on the producer side, processing the metadata
asynchronously, and so on.</p>

<h3 id="instrument-kafka-consumer-api">Instrument Kafka Consumer API</h3>

<p>Ok, so far so good. We have a complete visibility over the execution on
the producer side. But what happen next? How the consumer side reacts?</p>

<p>To know that using OpenTracing instrumentation we will using the same
integration of OpenTracing with Kafka, but it is a bit different.</p>

<p>Again, let&rsquo;s start adding dependencies:</p>

<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;io.opentracing&lt;/groupId&gt;
            &lt;artifactId&gt;opentracing-api&lt;/artifactId&gt;
            &lt;version&gt;0.30.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.uber.jaeger&lt;/groupId&gt;
            &lt;artifactId&gt;jaeger-core&lt;/artifactId&gt;
            &lt;version&gt;0.20.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.opentracing.contrib&lt;/groupId&gt;
            &lt;artifactId&gt;opentracing-kafka-client&lt;/artifactId&gt;
            &lt;version&gt;0.0.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>

<p><code>opentracing-api</code> and <code>jaeger-core</code> for instrumentation and <code>opentracing-kafka-client</code>
for integration with Kafka Clients.</p>

<p>Then, we need to instantiate the <code>Tracer</code>, but without the <code>DropwizardTracer</code>
given that we don&rsquo;t need to trace HTTP endpoints:</p>

<pre><code class="language-java">    //Instantiate and register Tracer
    final Tracer tracer =
        new com.uber.jaeger.Configuration(
            getName(),
            new com.uber.jaeger.Configuration.SamplerConfiguration(&quot;const&quot;, 1),
            new com.uber.jaeger.Configuration.ReporterConfiguration(
                true,  // logSpans
                &quot;localhost&quot;,
                6831,
                1000,   // flush interval in milliseconds
                10000)  /*max buffered Spans*/)
            .getTracer();
    GlobalTracer.register(tracer);
</code></pre>

<p>And then, instantiate the <code>TracingKafkaConsumer</code>:</p>

<pre><code class="language-java">    final TracingKafkaConsumer&lt;String, String&gt; tracingKafkaConsumer =
        new TracingKafkaConsumer&lt;&gt;(kafkaConsumer, tracer);

    //Define Runnable Handler
    final KafkaGreetingsHandler greetingsHandler =
        new KafkaGreetingsHandler(tracingKafkaConsumer)
</code></pre>

<p>Should be enough. Let&rsquo;s try it out:</p>

<p>(build and run your consumer side)</p>

<pre><code>./mvnw clean install
 java -jar target/hello-world-consumer.jar server config.yml
</code></pre>

<pre><code> curl http://localhost:8080/hello/jorge
</code></pre>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/trace-with-consumer.png" alt="Trace with Consumer" /></p>

<p>That&rsquo;s great! Now we have how long it takes to receive a record on the
consumer side.</p>

<p>But, what if we want to measure the complete execution, since we get
the message until we commit it?</p>

<p>To do this, we can add an <code>ActiveSpan</code> on the consumption side:</p>

<pre><code class="language-java">        for (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) {
          try (ActiveSpan activeSpan =
                   GlobalTracer.get()
                       .buildSpan(&quot;consumption&quot;)
                       //.asChildOf(context)
                       .startActive()) {
            System.out.println(consumerRecord.value());

            kafkaConsumer.commitSync();
          }
        }
</code></pre>

<p>But where is the context coming from?</p>

<p>Well, as <code>TracingKafkaProducer</code> inject tracing contexts on Headers,
we can use <code>TracingKafkaUtils</code> to extract it, and reference it:</p>

<pre><code class="language-java">        for (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) {
          final SpanContext context =
              TracingKafkaUtils.extractSpanContext(consumerRecord.headers(), tracer);
          try (ActiveSpan activeSpan =
                   tracer.buildSpan(&quot;consumption&quot;)
                       .asChildOf(context)
                       .startActive()) {
            System.out.println(consumerRecord.value());

            kafkaConsumer.commitSync();
          }
        }
</code></pre>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/complete-trace.png" alt="Complete trace" /></p>

<blockquote>
<p>Source code on branch: steps/step-03</p>
</blockquote>

<h1 id="recommendations">Recommendations</h1>

<h2 id="trace-tags">Trace Tags</h2>

<p>One important feature of OpenTracing API is supporting <code>tags</code>. These
help to reference metadata that enables reference to business data
that can be use to map your trace with a transaction.</p>

<p>Also don&rsquo;t try to overuse <code>tags</code> and use something like the Elastic Stack
or Splunk to store your logging messages, and use <code>tags</code> just to reference
the transaction ID, the entity ID or user ID.</p>

<p>For instance, in this case, we can add a tag to track the name:</p>

<p>On the producer side:</p>

<pre><code class="language-java">    try (ActiveSpan ignored =
             dropWizardTracer.getTracer()
                 .buildSpan(&quot;sayHi&quot;)
                 .asChildOf(span)
                 .withTag(&quot;user&quot;, name)
                 .startActive()) {
      producer.send(name);
      return Response.accepted(&quot;done.&quot;).build();
    }
</code></pre>

<p>And in the consumer side, the same story:</p>

<pre><code class="language-java">          try (ActiveSpan ignored =
                   tracer.buildSpan(&quot;consumption&quot;)
                       .withTag(&quot;user&quot;, consumerRecord.key())
                       .asChildOf(context)
                       .startActive()) {
            System.out.println(consumerRecord.value());

            kafkaConsumer.commitSync();
          }
</code></pre>

<p>And you can filter now from the UI:</p>

<p><img src="../../static/images/2017-09-28-kafka-opentracing/tags.png" alt="Complete trace" /></p>

<h2 id="dropwizard-helpers">Dropwizard Helpers</h2>

<p>I have developed some Dropwizard modules to help to instantiate
Kafka Clients, create Topics, instantiate Traces, and so on. I&rsquo;m working
on Documentation but you can find it on Maven Central already:</p>

<p><a href="https://github.com/jeqo/dropwizard-modules/">https://github.com/jeqo/dropwizard-modules/</a></p>

<p><a href="https://mvnrepository.com/artifact/io.github.jeqo.dropwizard">https://mvnrepository.com/artifact/io.github.jeqo.dropwizard</a></p>
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'jeqoblog';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        <div class="navbar">
        <ul class="navbar-list" style="...">
            
            <li class="navbar-item"><a class="navbar-link" href="https://github.com/jeqo/">GitHub</a></li>
            
            <li class="navbar-item"><a class="navbar-link" href="https://twitter.com/jeqo89">Twitter</a></li>
            
            <li class="navbar-item"><a class="navbar-link" href="index.xml">RSS</a></li>
            
        </ul>
    </div>
    <div class="copyright">
        <p>&copy; 2018. @jeqo. All rights reserved. </p>
    </div>
    
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-49047812-3', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</div>
</body>
</html>

