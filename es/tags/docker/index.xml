<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0">
    <channel>
        <title>Jorge Quilcate Otoya on @jeqo</title>
        <generator uri="https://gohugo.io">Hugo</generator>
        <link>https://jeqo.github.io/es/tags/docker/index.xml</link>
        <language>en-us</language>
        <author>Jorge Quilcate Otoya</author>
        
        <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
        
        <item>
            <title>Escalando Kafka con Docker Containers</title>
            <link>https://jeqo.github.io/es/post/2017-01-15-scale-kafka-containers/</link>
            <pubDate>Sun, 15 Jan 2017 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2017-01-15-scale-kafka-containers/</guid>
            <description>&lt;p&gt;En este post mostraré como utilizar contenedores Docker para crear y escalar
un clúster de Kafka, y también como crear, escalar y mover &lt;code&gt;topics&lt;/code&gt; dentro del
clúster.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Repositorio: &lt;a href=&#34;https://github.com/jeqo/post-scale-kafka-containers&#34;&gt;https://github.com/jeqo/post-scale-kafka-containers&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;clúster-de-un-nodo&#34;&gt;Clúster de un nodo&lt;/h1&gt;

&lt;p&gt;Primero, comenzaremos con la forma más sencilla de utilizar Docker, que puede
ser útil y suficiente para algunos escenarios de desarrollo: un &lt;strong&gt;clúster con
un nodo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;La arquitectura de &lt;em&gt;Apache Kafka&lt;/em&gt; esta basada en 2 components principales:
El propio &lt;em&gt;servidor de Apache Kakfa&lt;/em&gt;, y el &lt;em&gt;servidor de Apache Zookeeper&lt;/em&gt;,
utilizado por Kafka para su coordinación interna.&lt;/p&gt;

&lt;p&gt;Es por eso que un clúster de nodo simple require por lo menos de un par de
procesos.&lt;/p&gt;

&lt;p&gt;Si hablamos en terminos y prácticas de &lt;code&gt;contenedores&lt;/code&gt;, estos processos deberían
ejecutarse en dos contenedores diferentes.&lt;/p&gt;

&lt;p&gt;La forma más sencilla de definir estos procesos en Docker, es con
servicios de &lt;code&gt;Docker Compose&lt;/code&gt;, como están definidos en el archivo
&lt;code&gt;kafka-cluster/docker-compose.yml&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Usaré un par de imagenes. Son bastante simples, y el código fuente se encuentra
aquí:
&lt;a href=&#34;https://github.com/jeqo/docker-image-apache-kafka&#34;&gt;Apache Kafka&lt;/a&gt;,
&lt;a href=&#34;https://github.com/jeqo/docker-image-apache-zookeeper&#34;&gt;Apache Zookeeper&lt;/a&gt;, and
&lt;a href=&#34;https://github.com/jeqo/docker-image-confluent-platform&#34;&gt;Confluent Platform&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;version: &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;2.1&amp;quot;&lt;/span&gt;
services:
  kafka:
    image: jeqo/apache-kafka:0.10.1.0-2.11
    links:
      - zookeeper
  zookeeper:
    image: jeqo/apache-zookeeper:3.4.8
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta configuración define 2 servicios: &lt;code&gt;kafka&lt;/code&gt; y &lt;code&gt;zookeeper&lt;/code&gt;. El &lt;code&gt;link&lt;/code&gt; del&lt;br /&gt;
servicio &lt;code&gt;kafka&lt;/code&gt; y su variable de entorno &lt;code&gt;ZOOKEEPER_CONNECT&lt;/code&gt;
configuran el acceso desde &lt;code&gt;kafka&lt;/code&gt; hacia el servicio &lt;code&gt;zookeeper&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Si probamos iniciar los servicios con el comando &lt;code&gt;docker-compose up -d&lt;/code&gt;,
Docker Compose creará una red donde estos servicios se podrán comunicar.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;jeqo@jeqo-Oryx-Pro:.../single-node-kafka-cluster$ docker-compose up -d
Creating network &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;kafkacluster_default&amp;quot;&lt;/span&gt; with the default driver
Creating kafkacluster_zookeeper_1
Creating kafkacluster_kafka_1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si queremos acceder a estos servicios desde nuestra aplicación (también
  definida en Docker Compose) lo podemos hacer de la siguiente manera:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;version: &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;2.1&amp;quot;&lt;/span&gt;
services:
  kafka:
    image: jeqo/apache-kafka-client:0.10.1.0-2.11
    command: sleep infinity
    networks:
      - default
      - kafkacluster_default &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;#(2)&lt;/span&gt;
networks: &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;#(1)&lt;/span&gt;
  kafkacluster_default:
    external: true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Aquí definimos primero una red externa &lt;code&gt;external network&lt;/code&gt; llamada &lt;code&gt;singlenodekafkacluster_default&lt;/code&gt;
que nos permite acceder a la red del clúster de kafka.
Luego agregamos esta red a los servicios que requieren acceso, en este caso
el servicio &lt;code&gt;client&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para probar el acceso desde el cliente, primero iniciemos el servicio con
&lt;code&gt;docker-compose up -d&lt;/code&gt; y luego nos conectamos al servicio:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose &lt;span style=&#34;color: #008000&#34;&gt;exec&lt;/span&gt; kafka bash
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# bin/kafka-console-producer.sh --broker-list kafka:9092 --topic topic1&lt;/span&gt;
&lt;span style=&#34;color: #008000&#34;&gt;test&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# bin/kafka-topics.sh --zookeeper zookeeper:2181 --list      &lt;/span&gt;
topic1
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id=&#34;clúster-multi-nodo&#34;&gt;Clúster Multi-Nodo&lt;/h1&gt;

&lt;p&gt;Una vez creado nuestro clúster, escalar nuestro contenedor de ´kafka´
es tan sencillo como utilizar el comando &lt;code&gt;scale&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;docker-compose scale &lt;span style=&#34;color: #19177C&#34;&gt;kafka&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este comando creará dos contenedores adicionales:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose scale &lt;span style=&#34;color: #19177C&#34;&gt;kafka&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;3
Creating and starting kafkacluster_kafka_2 ... &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;done&lt;/span&gt;
Creating and starting kafkacluster_kafka_3 ... &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para nosotros, como desarrolladores(as) de aplicaciones, solo necesitamos
saber uno de los host o IPs de los &lt;code&gt;broker&lt;/code&gt; (nodo del clúster de Kafka),
para conectarnos al clúster. O también podemos usar el nombre del servicio.&lt;/p&gt;

&lt;p&gt;Como la documentación especifíca, el cliente (p.ejem: &lt;code&gt;productor&lt;/code&gt; o &lt;code&gt;consumidor&lt;/code&gt;)
solo utilizará este dato para iniciar la conexión y obtener la lista completa de
&lt;code&gt;brokers&lt;/code&gt; del clúster. Esto significa que la escalabilidad de Kafka es
transparente para nuestra aplicación.&lt;/p&gt;

&lt;p&gt;Para validar que todos los brokers son parte del clúster, usaremos el client
de Zookeeper.&lt;/p&gt;

&lt;p&gt;Desde el contenedor cliente:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose &lt;span style=&#34;color: #008000&#34;&gt;exec&lt;/span&gt; kafka bash
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;# bin/zookeeper-shell.sh zookeeper:2181&lt;/span&gt;
ls /brokers/ids
&lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;1003, 1002, 1001&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id=&#34;escalando-topics&#34;&gt;Escalando Topics&lt;/h1&gt;

&lt;p&gt;En Kafka, los &lt;code&gt;Topics&lt;/code&gt; son distribuidos en &lt;code&gt;Partitions&lt;/code&gt;. Las &lt;code&gt;Particiones&lt;/code&gt;
permiten la &lt;strong&gt;escalabilidad&lt;/strong&gt;, haciendo posible que los &lt;code&gt;Topics&lt;/code&gt; quepan en
varios nodos; y &lt;strong&gt;paralelismo&lt;/strong&gt;, dejando que distintas instancias de un mismo
&lt;strong&gt;Grupo de Consumidores&lt;/strong&gt; puedan consumir messages en paralelo.&lt;/p&gt;

&lt;p&gt;Aparte de este beneficio, Kafka tiene la habilidad de &lt;strong&gt;replicar&lt;/strong&gt; estas
&lt;code&gt;Particiones&lt;/code&gt;, logrando alta disponibilidad. En este case, si tienes varias &lt;code&gt;replicas&lt;/code&gt;
de una &lt;code&gt;partición&lt;/code&gt;, una será la partición &lt;code&gt;líder&lt;/code&gt; y las demás replicas serán
&lt;code&gt;seguidoras&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;agregando-nuevos-topics-al-clúster&#34;&gt;Agregando nuevos &lt;code&gt;Topics&lt;/code&gt; al clúster&lt;/h2&gt;

&lt;p&gt;Una vez que el clúster tiene mayor número de nodos, Kafka no utilizará estos
nuevos nodos hasta que nuevos tópicos sean creados.&lt;/p&gt;

&lt;p&gt;Veamos como probamos esto:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Iniciemos un clúster simple, con un solo nodo&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/9xzqgicktaqhzp1fofjk9ejgm.js&#34; id=&#34;asciicast-9xzqgicktaqhzp1fofjk9ejgm&#34; async&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Luego iniciemos un cliente, y creemos un topic &lt;code&gt;topic1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/2schnuetb24mjx6txopew51hc.js&#34; id=&#34;asciicast-2schnuetb24mjx6txopew51hc&#34; async&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Escalemos el clúster a 3 nodos&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/ahibdzz7xt67q53sc5ert6qdp.js&#34; id=&#34;asciicast-ahibdzz7xt67q53sc5ert6qdp&#34; async&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Agregemos topics para ocupar los demás brokers&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Usando múltiples particiones:&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/enq2czkpgdf0tbf3u6fwir3ml.js&#34; id=&#34;asciicast-enq2czkpgdf0tbf3u6fwir3ml&#34; async&gt;&lt;/script&gt;

&lt;p&gt;O usando varias réplicas:&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/f0u67h5ufiz4zkup84a1t8t5g.js&#34; id=&#34;asciicast-f0u67h5ufiz4zkup84a1t8t5g&#34; async&gt;&lt;/script&gt;

&lt;p&gt;Para decidir que &lt;code&gt;factor de replicación&lt;/code&gt; utilizar o cuantas  &lt;code&gt;particiones&lt;/code&gt;,
depende de cada caso de uso. Estos temas merecen su propio post.&lt;/p&gt;

&lt;h2 id=&#34;expandiendo-topics-en-el-clúster&#34;&gt;Expandiendo &lt;code&gt;Topics&lt;/code&gt; en el clúster&lt;/h2&gt;

&lt;p&gt;Expandir topics en el clúster significa mover &lt;code&gt;topics&lt;/code&gt; y &lt;code&gt;particiones&lt;/code&gt;
una vez que se tengan más &lt;code&gt;brokers&lt;/code&gt; en el &lt;code&gt;clúster&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Esto se puede realizar en 3 pasos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Identificar que &lt;code&gt;topics&lt;/code&gt; se quieren mover a un nuevo &lt;code&gt;broker&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generar el plan de reasignación. Esto se puede realizar de forma automática
o manual, si se sabe cómo redistribuir los topics.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ejecutar el plan de reasignación.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Estos pasos se encuentran documentados aquí: &lt;a href=&#34;http://kafka.apache.org/documentation/#basic_ops_cluster_expansion&#34;&gt;http://kafka.apache.org/documentation/#basic_ops_cluster_expansion&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;He automatizado un poco los pasos con unos script en Ansible:&lt;/p&gt;

&lt;p&gt;Dentro del archivo &lt;code&gt;playbooks/prepare-reassignment.yml&lt;/code&gt; hay dos variables a definir:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;vars:
  topics:
    - topic1
  broker_list: 1003
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Estas prepararán un plan para mover el topic &lt;code&gt;topic1&lt;/code&gt; al &lt;code&gt;broker&lt;/code&gt; con id &lt;code&gt;1003&lt;/code&gt;.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/c6332x8t7yumpj65ie4qudgem.js&#34; id=&#34;asciicast-c6332x8t7yumpj65ie4qudgem&#34; async&gt;&lt;/script&gt;

&lt;p&gt;Puedes copiar ese JSON generado en &lt;code&gt;playbooks/reassign-topic-plan.json&lt;/code&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;&amp;quot;version&amp;quot;&lt;/span&gt;:&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;&amp;quot;partitions&amp;quot;&lt;/span&gt;:[{&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;&amp;quot;topic&amp;quot;&lt;/span&gt;:&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;topic1&amp;quot;&lt;/span&gt;,&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;&amp;quot;partition&amp;quot;&lt;/span&gt;:&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;&amp;quot;replicas&amp;quot;&lt;/span&gt;:[&lt;span style=&#34;color: #666666&#34;&gt;1003&lt;/span&gt;]}]
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y ejecutar el otro playbook: &lt;code&gt;playbooks/execute-reassignment.yml&lt;/code&gt;&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/99308.js&#34; id=&#34;asciicast-99308&#34; async&gt;&lt;/script&gt;

&lt;h1 id=&#34;confluent-platform-images&#34;&gt;Confluent Platform images&lt;/h1&gt;

&lt;p&gt;Todos estos pasos se pueden ejecutar igualmente con
&lt;a href=&#34;https://www.confluent.io/&#34;&gt;Confluent Platform&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para ello, agregué los directorios &lt;code&gt;confluent-cluster&lt;/code&gt; y &lt;code&gt;confluent-client&lt;/code&gt; para
poder probarlo:&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/a446bixdfn3l8xqoiolmsmlqg.js&#34; id=&#34;asciicast-a446bixdfn3l8xqoiolmsmlqg&#34; async&gt;&lt;/script&gt;

&lt;p&gt;Espero que este post los ayude a entender un poco más sobre los &lt;code&gt;topics&lt;/code&gt; en
Kafka y como los &lt;code&gt;contenedores&lt;/code&gt; nos pueden ayudar a crear clústers en segundos :)&lt;/p&gt;

&lt;p&gt;Y, ya saben, ejecuten &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;es&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;.&lt;a href=&#34;https://twitter.com/apachekafka&#34;&gt;@apachekafka&lt;/a&gt; everywhere :) &lt;a href=&#34;https://t.co/AcEmkRBCpv&#34;&gt;pic.twitter.com/AcEmkRBCpv&lt;/a&gt;&lt;/p&gt;&amp;mdash; Gwen (Chen) Shapira (@gwenshap) &lt;a href=&#34;https://twitter.com/gwenshap/status/777660752626851840&#34;&gt;19 de septiembre de 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;</description>
        </item>
        
        <item>
            <title>Ansible - Provisionamiento sin agentes</title>
            <link>https://jeqo.github.io/es/post/2016-03-30-ansible-agentless-provisioning/</link>
            <pubDate>Wed, 30 Mar 2016 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2016-03-30-ansible-agentless-provisioning/</guid>
            <description>

&lt;p&gt;Ansible es una herramienta de automatización reconocida por ser sencilla
y potente a la vez. Según mi experiencia, puedo decir que esto se debe
principalmente al lenguaje que utiliza: YAML, y a tener una arquitectura
sin agentes o &amp;ldquo;agentless&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;yaml-y-los-componentes-de-ansible&#34;&gt;YAML y los componentes de Ansible&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;YAML is a human friendly data serialization standard for all programming
  languages&amp;rdquo; (Source: &lt;a href=&#34;http://yaml.org/&#34;&gt;http://yaml.org/&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esto signifíca que es verdaderamente fácil de entender y comenzar a trabajar
con YAML. Por ejemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: webserver
  tasks:
    - package: apache
        state: latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este &lt;strong&gt;&amp;ldquo;playbook&amp;rdquo;&lt;/strong&gt; dice que el host &lt;em&gt;webserver&lt;/em&gt; que tiene 1 tarea: instalar
el paquete más actual de Apache, usando el &lt;strong&gt;&amp;ldquo;module&amp;rdquo;&lt;/strong&gt; &lt;em&gt;package&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bastante sencillo no?&lt;/p&gt;

&lt;p&gt;Para revisar que tan potente puede ser Ansible, se puede revisar el índice
de Modules:
&lt;a href=&#34;http://docs.ansible.com/ansible/modules_by_category.html&#34;&gt;http://docs.ansible.com/ansible/modules_by_category.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para lograr reusabilidad: estas tareas pueden ser agrupadas como &lt;strong&gt;&amp;ldquo;roles&amp;rdquo;&lt;/strong&gt;,
que son una compilación de tareas que buscan cumplir un objetivo común.
Por ejemplo: un rol Java para instalar JDK en tu nodo.&lt;/p&gt;

&lt;p&gt;Estos son los componentes principales de Ansible: Playbooks, Modules, and Roles.&lt;/p&gt;

&lt;h2 id=&#34;arquitectura-agentless&#34;&gt;Arquitectura &amp;ldquo;Agentless&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;Esto significa que no necesitas un &amp;ldquo;ansible-client&amp;rdquo; en tus nodos para ejecutar
tareas. Tu solo necesitarías un &amp;ldquo;master&amp;rdquo; que diga que tareas ejecutar en tus
nodos. Esto es muy importante comparado con otras herramientas, donde necesitas
un &amp;ldquo;***-client&amp;rdquo; para poder interpretar y ejecutar los comandos:
&lt;a href=&#34;https://www.ansible.com/benefits-of-agentless-architecture&#34;&gt;https://www.ansible.com/benefits-of-agentless-architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Es verdad que no necesitas un cliente con Ansible, pero requires de algunos
paquetes. Pero estos paquetes son SSH y otros relacionados a Python, que son
bastante comunes:
&lt;a href=&#34;http://docs.ansible.com/ansible/intro_installation.html#managed-node-requirements&#34;&gt;http://docs.ansible.com/ansible/intro_installation.html#managed-node-requirements&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ansible también mantiene un enfoque &amp;ldquo;push&amp;rdquo;, donde el &amp;ldquo;master&amp;rdquo; envía comandos a
los nodos. Esto también diferente a otras herramientas que están basadas en un
enfoque &amp;ldquo;push&amp;rdquo;, donde los nodos piden los comandos a un &amp;ldquo;master&amp;rdquo;. Aunque este
enfoque es opcional con Ansible:
&lt;a href=&#34;http://docs.ansible.com/ansible/playbooks_intro.html#ansible-pull&#34;&gt;http://docs.ansible.com/ansible/playbooks_intro.html#ansible-pull&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Por último, hay una funcionalidad que quiero mencionar: Tipo de Conexión.
Por defecto, Ansible se basa en SSH para ejecutar comandos en los nodos, pero
hay casos en los que SSH no es una opción o no se necesita: por ejemplo para
ejecutar comandos localmente, o en Windows, o en Docker.&lt;/p&gt;

&lt;p&gt;En estos casos, la opción de tipo de conexión permite que tus &amp;ldquo;playbook&amp;rdquo; se
ejecuten usando WinRM si tu nodo es Windows, o ejecutarlos localmente, o
utilizar comandos Docker Exec.&lt;/p&gt;

&lt;p&gt;Vamos a ver un poco de código:&lt;/p&gt;

&lt;p&gt;He implementedo un role de Ansible para instalar Java hace algún tiempo:
&lt;a href=&#34;https://github.com/jeqo/ansible-role-java&#34;&gt;https://github.com/jeqo/ansible-role-java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Solo para explicar que hace, vemos el archivo de tareas principal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
  - debug:
      msg: &amp;quot;This Java Provider will be installed: {{ java_provider }}&amp;quot;

  - include: install-{{ java_provider }}.yml

  - include: set-java-home.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primero muestra un mensaje con el tipo de proveedor:
variable &amp;ldquo;java_provider&amp;rdquo; y luego definir la variable de entorno: JAVA_HOME.&lt;/p&gt;

&lt;p&gt;Este rol también tiene una carpeta de pruebas &amp;ldquo;tests&amp;rdquo;, con un &amp;ldquo;playbook&amp;rdquo; con
algunas pruebas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- name: test install openjdk jdk 8 on centos 7
  hosts: test01
  roles:
    - role: java
      java_provider: openjdk
      java_version: 8
      java_type: jdk
- name: test install openjdk jre 8 on centos 7
  hosts: test02
  roles:
    - role: java
      java_provider: openjdk
      java_version: 8
      java_type: jre
# more tests...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y para ejecutar las pruebas utilizo Vagrant y VirtualBox:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Vagrant.configure(2) do |config|

  config.vm.provision &amp;quot;ansible&amp;quot; do |ansible|
    ansible.playbook = &amp;quot;test.yml&amp;quot;
    ansible.galaxy_role_file = &amp;quot;roles.yml&amp;quot;
  end

  config.vm.define &amp;quot;test01&amp;quot; do |node|
    node.vm.box = &amp;quot;jeqo/ansible-centos7&amp;quot;
  end

  config.vm.define &amp;quot;test02&amp;quot; do |node|
    node.vm.box = &amp;quot;jeqo/ansible-centos7&amp;quot;
  end

  # more test nodes...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ejecutemos la prueba de instalación de OpenJDK 8 en Centos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant up test01
...

PLAY [test install openjdk jdk 8 on centos 7] **********************************

TASK [setup] *******************************************************************
ok: [test01]

TASK [java : debug] ************************************************************
ok: [test01] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;This Java Provider will be installed: openjdk&amp;quot;
}

TASK [java : include] **********************************************************
included: /home/jeqo/dev/jeqo/ansible-role-java/tests/roles/java/tasks/install-openjdk.yml for test01

TASK [java : set_fact] *********************************************************
skipping: [test01]

TASK [java : set_fact] *********************************************************
ok: [test01]

TASK [java : set_fact] *********************************************************
skipping: [test01]

TASK [java : set_fact] *********************************************************
ok: [test01]

TASK [java : install openjdk (debian)] *****************************************
skipping: [test01]

TASK [java : install openjdk (redhat)] *****************************************

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pero que pasa si quiero ejecutar este rol en Docker? Necesito configurar
SSH para hacerlo utilizando el modo de conexión por defecto. Esto es
considerado un anti-patrón:
&lt;a href=&#34;https://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/&#34;&gt;https://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pero, desde la versión 2.0 de Ansible que tiene el tipo de conexión Docker
incluido en la instalación. Así que hice algunas pruebas:
&lt;a href=&#34;https://github.com/jeqo/poc-ansible-docker&#34;&gt;https://github.com/jeqo/poc-ansible-docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;En este repositorio tengo un &amp;ldquo;playbook&amp;rdquo; que crea el contenedor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: 127.0.0.1
  connection: local
  tasks:
    - name: my container
      docker:
        name: poccontainer
        image: centos
        command: sleep infinity
        state: started
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aquí utilizo el tipo de tipo de conexión local para ejecutar comandos
localmente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
a5e49bd032be        centos              &amp;quot;sleep infinity&amp;quot;    About an hour ago   Up About an hour                        poccontainer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez que tenga el contenedor en ejecución, se puede ejecutar
el provisionamiento:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: poccontainer
  connection: docker
  pre_tasks:
    - package: name=sudo
    - command: &amp;quot;sed -i -e \&amp;quot;s/Defaults    requiretty.*/ #Defaults    requiretty/g\&amp;quot; /etc/sudoers&amp;quot;
  roles:
    - role: java
      java_provider: openjdk
      java_type: jdk
      java_version: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las &amp;ldquo;pre-tasks&amp;rdquo; se necesitan para configurar el paquete &amp;ldquo;sudo&amp;rdquo; y poder
configurar &amp;ldquo;tty&amp;rdquo; en el contenedos. Esto se requiere cuando ejecutar un
&amp;ldquo;playbook&amp;rdquo; con el parámetro: &amp;ldquo;become&amp;rdquo;, que ejecuta un comando como &amp;ldquo;sudo&amp;rdquo;.
Luego se ejecuta el rol como en cualquier nodo:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ ansible-playbook provisioning.yml -vvvv
Using /home/jeqo/dev/jeqo/poc-ansible-docker/ansible.cfg as config file
Loaded callback default of &lt;span style=&#34;color: #008000&#34;&gt;type&lt;/span&gt; stdout, v2.0
&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; plays in provisioning.yml

PLAY ***************************************************************************

TASK &lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;setup&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt; *******************************************************************
ESTABLISH DOCKER CONNECTION FOR USER: None
&amp;lt;poccontainer&amp;gt; EXEC &lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;/usr/bin/docker&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;exec&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;, u&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;poccontainer&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;/bin/sh&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;/bin/sh -c \&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;umask&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;22&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
mkdir -p &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;` echo &lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;$HOME&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729 `&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
&lt;span style=&#34;color: #008000&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;` echo &lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;$HOME&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729 `&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;]&lt;/span&gt;
&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;lt;poccontainer&amp;gt; PUT /tmp/tmpNCOaxi TO /root/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729/setup&lt;/span&gt;
&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;lt;poccontainer&amp;gt; EXEC [&amp;#39;&lt;/span&gt;/usr/bin/docker&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;exec&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;-i&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, u&amp;#39;&lt;/span&gt;poccontainer&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;/bin/sh&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;-c&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, u&amp;#39;&lt;/span&gt;/bin/sh -c &lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;LANG&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;en_US.UTF-8 
&lt;span style=&#34;color: #19177C&#34;&gt;LC_ALL&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;en_US.UTF-8 &lt;span style=&#34;color: #19177C&#34;&gt;LC_MESSAGES&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;en_US.UTF-8 /usr/bin/python /root/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729/setup; 
rm -rf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;/root/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729/&amp;quot;&lt;/span&gt; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt;
ok: &lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;poccontainer&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Estos ejemplos muestran cual versátil es Ansible, usando roles y tipos de
conexión. Pero hay más plataformas donde Ansible puede ser utilizada, como AWS:
&lt;a href=&#34;https://aws.amazon.com/blogs/apn/getting-started-with-ansible-and-dynamic-amazon-ec2-inventory-management/&#34;&gt;https://aws.amazon.com/blogs/apn/getting-started-with-ansible-and-dynamic-amazon-ec2-inventory-management/&lt;/a&gt;
y otras plataformas en la nube:
&lt;a href=&#34;http://docs.ansible.com/ansible/list_of_cloud_modules.html&#34;&gt;http://docs.ansible.com/ansible/list_of_cloud_modules.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Una posible pregunta puede ser: ¿Puede Ansible reemplazar los Dockerfile?
Puede ser, depende de ti. Los Dockerfile son bastante sencillos y solo
funcionan en Docker. Los Dockerfile también tiene una característica interesante
que crea una imagen en cada paso de ejecución, lo que hace que la distribución
de imágenes sea más sencilla. Esto falta aún en Ansible, donde los comandos
se ejecutan sobre un contenedor en ejecución. En Ansible también está faltando
las opciones de &amp;ldquo;commit&amp;rdquo; y &amp;ldquo;push&amp;rdquo; en Docker, pero esto se puede reemplazar
facilmente así:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: 127.0.0.1
  connection: local
  tasks:
    - name: commit
      command: docker commit poccontainer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin embargo, Ansible también tiene un módulo para ejecutar Dockerfiles:
&lt;a href=&#34;http://docs.ansible.com/ansible/docker_image_module.html&#34;&gt;http://docs.ansible.com/ansible/docker_image_module.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Espero que esto les ayude a utilizar Ansible y Docker.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Imagen de Oracle SOA Suite 12c en Docker</title>
            <link>https://jeqo.github.io/es/post/2015-09-04-oracle-soa-12c-packer-docker-hub/</link>
            <pubDate>Fri, 04 Sep 2015 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2015-09-04-oracle-soa-12c-packer-docker-hub/</guid>
            <description>

&lt;p&gt;Luego de encontrar algunas limitaciones en la construcción de una imagen en
Docker con Oracle SOA Suite 12c instalado usando Dockerfiles (como acceso
a volumenes, tamaño de filesystem por defecto), he investigado como
mejorar este proceso, y he encontrado &lt;a href=&#34;https://packer.io/&#34;&gt;Packer&lt;/a&gt;
(del mismo equipo que creo Vagrant, Hashicorp).&lt;/p&gt;

&lt;p&gt;Para obtener mayor información sobre porqué utilizar Packer en vez de
Dockerfiles, &lt;a href=&#34;http://mmckeen.net/blog/2013/12/27/advanced-docker-provisioning-with-packer/&#34;&gt;ir aquí&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;También he movido el directory &lt;a href=&#34;https://github.com/jeqo/oracle-docker/tree/master/OracleSOA&#34;&gt;OracleSOA&lt;/a&gt;
que cree sobre el repositorio de Oracle Docker &lt;a href=&#34;https://github.com/oracle/docker&#34;&gt;oracle-docker&lt;/a&gt;
hacia un repositorio independiente: &lt;a href=&#34;https://github.com/jeqo/oracle-soa-12c-docker&#34;&gt;github.com/jeqo/oracle-soa-12c-docker&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mejoras&#34;&gt;Mejoras&lt;/h2&gt;

&lt;p&gt;Basicamente, los scripts de Dockerfile fueron transformados en shell scripts
y son invocados desde Packer en la etapa de provisionamiento&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;provisioners&amp;quot;: [
    {
      &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
      &amp;quot;scripts&amp;quot;: [
        &amp;quot;scripts/create-user.sh&amp;quot;
      ]
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;file&amp;quot;,
      &amp;quot;source&amp;quot;: &amp;quot;./files/&amp;quot;,
      &amp;quot;destination&amp;quot;: &amp;quot;/u01/&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
      &amp;quot;scripts&amp;quot;: [
        &amp;quot;scripts/install-java.sh&amp;quot;
      ],
      &amp;quot;environment_vars&amp;quot;: [
        &amp;quot;JAVA_RPM=/data/{{user `java_rpm`}}&amp;quot;
      ]
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
      &amp;quot;scripts&amp;quot;: [
        &amp;quot;scripts/install-soa.sh&amp;quot;
      ],
      &amp;quot;environment_vars&amp;quot;: [
        &amp;quot;SOA_ZIP=/data/{{user `soa_zip`}}&amp;quot;,
        &amp;quot;SOA_PKG={{user `soa_pkg`}}&amp;quot;,
        &amp;quot;SOA_PKG2={{user `soa_pkg2`}}&amp;quot;,
        &amp;quot;JAVA_HOME=/usr/java/default&amp;quot;,
        &amp;quot;MW_HOME=/u01/oracle/soa&amp;quot;
      ]
    }
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luego del provisionamiento exitoso, se procesa la imagen para
guardarla en Docker Hub:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;post-processors&amp;quot;: [
    [
      {
        &amp;quot;type&amp;quot;: &amp;quot;docker-tag&amp;quot;,
        &amp;quot;repository&amp;quot;: &amp;quot;jeqo/oracle-soa-12c&amp;quot;,
        &amp;quot;tag&amp;quot;: &amp;quot;12.1.3-dev&amp;quot;
      },
      &amp;quot;docker-push&amp;quot;
    ]
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Realmente la configuración en JSON es bastante simple y concreta.&lt;/p&gt;

&lt;p&gt;Una vez que la imagen esta cargada en Docker Hub, se puede utilizar
la herramienta preferida: Docker, Dockerfiles, o Vagrant, para crear un
dominio sobre la imagen creada. &lt;a href=&#34;https://github.com/jeqo/oracle-soa-12c-docker/tree/master/samples/12c-domain&#34;&gt;Ejemplo&lt;/a&gt;
explicado en mi &lt;a href=&#34;http://jeqo.github.io/blog/devops/docker-image-oracle-soa-es/&#34;&gt;post anterior&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Oracle SOA Suite 12c sobre Docker</title>
            <link>https://jeqo.github.io/es/post/2015-04-01-docker-image-oracle-soa/</link>
            <pubDate>Wed, 01 Apr 2015 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2015-04-01-docker-image-oracle-soa/</guid>
            <description>

&lt;p&gt;Buenas noticias llegaron desde Oracle hace un par de semanas: &lt;a href=&#34;https://blogs.oracle.com/WebLogicServer/entry/oracle_weblogic_server_now_running&#34;&gt;Oracle WebLogic Server es ahora soportado en  Docker!&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;es&#34;&gt;&lt;p&gt;I&amp;#39;m glad we announced support for &lt;a href=&#34;https://twitter.com/OracleWebLogic&#34;&gt;@OracleWebLogic&lt;/a&gt; on &lt;a href=&#34;https://twitter.com/docker&#34;&gt;@Docker&lt;/a&gt; last week, not today :-) &lt;a href=&#34;https://t.co/6E9UxrgY3n&#34;&gt;https://t.co/6E9UxrgY3n&lt;/a&gt;&lt;/p&gt;&amp;mdash; Bruno Borges  (@brunoborges) &lt;a href=&#34;https://twitter.com/brunoborges/status/583252433343758336&#34;&gt;abril 1, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Esto es muy emocionante. &lt;strong&gt;Docker&lt;/strong&gt; es una nueva tecnología que propone una nueva forma de virtualización
a través de contenedores (OS, Configurations, Platform, Application) Para &lt;a href=&#34;https://www.docker.com/whatisdocker/&#34;&gt;más información acerca de Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bueno, WebLogic sobre Docker es genial, pero me he propuesto ir unos pasos más adelante y &lt;em&gt;Dockerize&lt;/em&gt; los
productos de &lt;strong&gt;SOA&lt;/strong&gt; y &lt;strong&gt;BPM&lt;/strong&gt;  (como &lt;a href=&#34;https://guidoschmutz.wordpress.com/2015/03/29/installing-oracle-stream-explorer-in-a-docker-image/&#34;&gt;Guido Schmitz hizo con  Oracle Stream Explorer&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;es&#34;&gt;&lt;p&gt;Just published my latest blog “Providing Oracle Stream Explorer environment using Docker”. &lt;a href=&#34;https://twitter.com/hashtag/oracle?src=hash&#34;&gt;#oracle&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/StreamExplorer?src=hash&#34;&gt;#StreamExplorer&lt;/a&gt; &lt;a href=&#34;http://t.co/WNFGCmFVca&#34;&gt;http://t.co/WNFGCmFVca&lt;/a&gt;&lt;/p&gt;&amp;mdash; gschmutz (@gschmutz) &lt;a href=&#34;https://twitter.com/gschmutz/status/582232826772357120&#34;&gt;marzo 29, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;He utilizado el &lt;a href=&#34;http://github.com/oracle/docker&#34;&gt;repositorio de Oracle&lt;/a&gt; como base para crear una
imagen con Oracle SOA Suite 12c instalado, y una configuración para utilizar esa imagen en la
creación de otro contenedor con un dominio listo para ejecutar.&lt;/p&gt;

&lt;h2 id=&#34;obtener-el-repositorio&#34;&gt;Obtener el repositorio&lt;/h2&gt;

&lt;p&gt;Para probar esta entrada del blog, debe tener instalado &lt;a href=&#34;https://docs.docker.com/&#34;&gt;Docker en su máquina&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El repositorio se encuentra ubicado en: &lt;a href=&#34;http://github.com/jeqo/oracle-docker&#34;&gt;http://github.com/jeqo/oracle-docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mi contribución está en la carpeta &lt;a href=&#34;https://github.com/jeqo/oracle-docker/tree/master/OracleSOA&#34;&gt;&amp;lsquo;OracleSOA&amp;rsquo;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;creación-de-la-imagen-con-oracle-soa-suite-12c&#34;&gt;Creación de la imagen con Oracle SOA Suite 12c&lt;/h2&gt;

&lt;p&gt;Primero se deben &lt;a href=&#34;http://www.oracle.com/technetwork/middleware/soasuite/downloads/index.html&#34;&gt;descargar los instaladores de Oracle SOA Suite 12c Quick Start&lt;/a&gt;,
y colocarlos en la carpeta OracleSOA/dockerfiles/12.1.3. De la misma forma
 &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&#34;&gt;descargar Java Development Kit 7&lt;/a&gt;,
 y colocarlo en el mismo folder.&lt;/p&gt;

&lt;p&gt;Abrir un terminal en el directorio &lt;em&gt;OracleSOA&lt;/em&gt;, ir a dockerfiles, y ejecutar el script &lt;em&gt;buildDockerImage.sh&lt;/em&gt; con el argumento &lt;em&gt;-d&lt;/em&gt; que indica que es la versión de desarrollo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh buildDockerImage.sh -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta ejecución crear una imagen llamada: &lt;strong&gt;oracle/soa:12.1.3-dev&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;dockerize-un-dominio-con-soa-suite&#34;&gt;Dockerize un dominio con SOA Suite&lt;/h2&gt;

&lt;p&gt;Ahora que tenemos una imagen Docker con SOA instalado, podemos reutilizarla para
crear dominios con WLST.&lt;/p&gt;

&lt;p&gt;Existe un ejemplo de este procedimiento en &lt;em&gt;OracleSOA/samples&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para ejecutarlo, ir a &lt;em&gt;OracleSOA/samples/12c-domain&lt;/em&gt; y correr el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t mysoa .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esto debe crear un imagen &lt;em&gt;mysoa&lt;/em&gt; que contiene un Compact Domain instalado en: &lt;em&gt;/u01/oracle/work/domains/soa-domain&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eso es todo! Para crear un contenedor desde la imagen, ejecutar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -i -t mysoa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BPM sobre Docker&lt;/li&gt;
&lt;li&gt;Publicar imagenes en Docker Hub Registry&lt;/li&gt;
&lt;li&gt;Dominios Extendidos sobre Docker: Usar una base de datos Oracle Database para instalar Oracle SOA/BPM Schemas&lt;/li&gt;
&lt;li&gt;SOA/BPM Cluster sobre Docker containers&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
