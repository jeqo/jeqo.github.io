<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0">
    <channel>
        <title>Jorge Quilcate Otoya on @jeqo</title>
        <generator uri="https://gohugo.io">Hugo</generator>
        <link>https://jeqo.github.io/es/post/index.xml</link>
        <language>en-us</language>
        <author>Jorge Quilcate Otoya</author>
        
        <updated>Wed, 30 Mar 2016 00:00:00 UTC</updated>
        
        <item>
            <title>Ansible - Provisionamiento sin agentes</title>
            <link>https://jeqo.github.io/es/post/2016-03-30-ansible-agentless-provisioning/</link>
            <pubDate>Wed, 30 Mar 2016 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2016-03-30-ansible-agentless-provisioning/</guid>
            <description>

&lt;p&gt;Ansible es una herramienta de automatización reconocida por ser sencilla
y potente a la vez. Según mi experiencia, puedo decir que esto se debe
principalmente al lenguaje que utiliza: YAML, y a tener una arquitectura
sin agentes o &amp;ldquo;agentless&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;yaml-y-los-componentes-de-ansible&#34;&gt;YAML y los componentes de Ansible&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;YAML is a human friendly data serialization standard for all programming
  languages&amp;rdquo; (Source: &lt;a href=&#34;http://yaml.org/&#34;&gt;http://yaml.org/&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esto signifíca que es verdaderamente fácil de entender y comenzar a trabajar
con YAML. Por ejemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: webserver
  tasks:
    - package: apache
        state: latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este &lt;strong&gt;&amp;ldquo;playbook&amp;rdquo;&lt;/strong&gt; dice que el host &lt;em&gt;webserver&lt;/em&gt; que tiene 1 tarea: instalar
el paquete más actual de Apache, usando el &lt;strong&gt;&amp;ldquo;module&amp;rdquo;&lt;/strong&gt; &lt;em&gt;package&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bastante sencillo no?&lt;/p&gt;

&lt;p&gt;Para revisar que tan potente puede ser Ansible, se puede revisar el índice
de Modules:
&lt;a href=&#34;http://docs.ansible.com/ansible/modules_by_category.html&#34;&gt;http://docs.ansible.com/ansible/modules_by_category.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para lograr reusabilidad: estas tareas pueden ser agrupadas como &lt;strong&gt;&amp;ldquo;roles&amp;rdquo;&lt;/strong&gt;,
que son una compilación de tareas que buscan cumplir un objetivo común.
Por ejemplo: un rol Java para instalar JDK en tu nodo.&lt;/p&gt;

&lt;p&gt;Estos son los componentes principales de Ansible: Playbooks, Modules, and Roles.&lt;/p&gt;

&lt;h2 id=&#34;arquitectura-agentless&#34;&gt;Arquitectura &amp;ldquo;Agentless&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;Esto significa que no necesitas un &amp;ldquo;ansible-client&amp;rdquo; en tus nodos para ejecutar
tareas. Tu solo necesitarías un &amp;ldquo;master&amp;rdquo; que diga que tareas ejecutar en tus
nodos. Esto es muy importante comparado con otras herramientas, donde necesitas
un &amp;ldquo;***-client&amp;rdquo; para poder interpretar y ejecutar los comandos:
&lt;a href=&#34;https://www.ansible.com/benefits-of-agentless-architecture&#34;&gt;https://www.ansible.com/benefits-of-agentless-architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Es verdad que no necesitas un cliente con Ansible, pero requires de algunos
paquetes. Pero estos paquetes son SSH y otros relacionados a Python, que son
bastante comunes:
&lt;a href=&#34;http://docs.ansible.com/ansible/intro_installation.html#managed-node-requirements&#34;&gt;http://docs.ansible.com/ansible/intro_installation.html#managed-node-requirements&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ansible también mantiene un enfoque &amp;ldquo;push&amp;rdquo;, donde el &amp;ldquo;master&amp;rdquo; envía comandos a
los nodos. Esto también diferente a otras herramientas que están basadas en un
enfoque &amp;ldquo;push&amp;rdquo;, donde los nodos piden los comandos a un &amp;ldquo;master&amp;rdquo;. Aunque este
enfoque es opcional con Ansible:
&lt;a href=&#34;http://docs.ansible.com/ansible/playbooks_intro.html#ansible-pull&#34;&gt;http://docs.ansible.com/ansible/playbooks_intro.html#ansible-pull&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Por último, hay una funcionalidad que quiero mencionar: Tipo de Conexión.
Por defecto, Ansible se basa en SSH para ejecutar comandos en los nodos, pero
hay casos en los que SSH no es una opción o no se necesita: por ejemplo para
ejecutar comandos localmente, o en Windows, o en Docker.&lt;/p&gt;

&lt;p&gt;En estos casos, la opción de tipo de conexión permite que tus &amp;ldquo;playbook&amp;rdquo; se
ejecuten usando WinRM si tu nodo es Windows, o ejecutarlos localmente, o
utilizar comandos Docker Exec.&lt;/p&gt;

&lt;p&gt;Vamos a ver un poco de código:&lt;/p&gt;

&lt;p&gt;He implementedo un role de Ansible para instalar Java hace algún tiempo:
&lt;a href=&#34;https://github.com/jeqo/ansible-role-java&#34;&gt;https://github.com/jeqo/ansible-role-java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Solo para explicar que hace, vemos el archivo de tareas principal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
  - debug:
      msg: &amp;quot;This Java Provider will be installed: {{ java_provider }}&amp;quot;

  - include: install-{{ java_provider }}.yml

  - include: set-java-home.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primero muestra un mensaje con el tipo de proveedor:
variable &amp;ldquo;java_provider&amp;rdquo; y luego definir la variable de entorno: JAVA_HOME.&lt;/p&gt;

&lt;p&gt;Este rol también tiene una carpeta de pruebas &amp;ldquo;tests&amp;rdquo;, con un &amp;ldquo;playbook&amp;rdquo; con
algunas pruebas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- name: test install openjdk jdk 8 on centos 7
  hosts: test01
  roles:
    - role: java
      java_provider: openjdk
      java_version: 8
      java_type: jdk
- name: test install openjdk jre 8 on centos 7
  hosts: test02
  roles:
    - role: java
      java_provider: openjdk
      java_version: 8
      java_type: jre
# more tests...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y para ejecutar las pruebas utilizo Vagrant y VirtualBox:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Vagrant.configure(2) do |config|

  config.vm.provision &amp;quot;ansible&amp;quot; do |ansible|
    ansible.playbook = &amp;quot;test.yml&amp;quot;
    ansible.galaxy_role_file = &amp;quot;roles.yml&amp;quot;
  end

  config.vm.define &amp;quot;test01&amp;quot; do |node|
    node.vm.box = &amp;quot;jeqo/ansible-centos7&amp;quot;
  end

  config.vm.define &amp;quot;test02&amp;quot; do |node|
    node.vm.box = &amp;quot;jeqo/ansible-centos7&amp;quot;
  end

  # more test nodes...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ejecutemos la prueba de instalación de OpenJDK 8 en Centos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant up test01
...

PLAY [test install openjdk jdk 8 on centos 7] **********************************

TASK [setup] *******************************************************************
ok: [test01]

TASK [java : debug] ************************************************************
ok: [test01] =&amp;gt; {
    &amp;quot;msg&amp;quot;: &amp;quot;This Java Provider will be installed: openjdk&amp;quot;
}

TASK [java : include] **********************************************************
included: /home/jeqo/dev/jeqo/ansible-role-java/tests/roles/java/tasks/install-openjdk.yml for test01

TASK [java : set_fact] *********************************************************
skipping: [test01]

TASK [java : set_fact] *********************************************************
ok: [test01]

TASK [java : set_fact] *********************************************************
skipping: [test01]

TASK [java : set_fact] *********************************************************
ok: [test01]

TASK [java : install openjdk (debian)] *****************************************
skipping: [test01]

TASK [java : install openjdk (redhat)] *****************************************

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pero que pasa si quiero ejecutar este rol en Docker? Necesito configurar
SSH para hacerlo utilizando el modo de conexión por defecto. Esto es
considerado un anti-patrón:
&lt;a href=&#34;https://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/&#34;&gt;https://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pero, desde la versión 2.0 de Ansible que tiene el tipo de conexión Docker
incluido en la instalación. Así que hice algunas pruebas:
&lt;a href=&#34;https://github.com/jeqo/poc-ansible-docker&#34;&gt;https://github.com/jeqo/poc-ansible-docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;En este repositorio tengo un &amp;ldquo;playbook&amp;rdquo; que crea el contenedor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: 127.0.0.1
  connection: local
  tasks:
    - name: my container
      docker:
        name: poccontainer
        image: centos
        command: sleep infinity
        state: started
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aquí utilizo el tipo de tipo de conexión local para ejecutar comandos
localmente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
a5e49bd032be        centos              &amp;quot;sleep infinity&amp;quot;    About an hour ago   Up About an hour                        poccontainer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez que tenga el contenedor en ejecución, se puede ejecutar
el provisionamiento:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: poccontainer
  connection: docker
  pre_tasks:
    - package: name=sudo
    - command: &amp;quot;sed -i -e \&amp;quot;s/Defaults    requiretty.*/ #Defaults    requiretty/g\&amp;quot; /etc/sudoers&amp;quot;
  roles:
    - role: java
      java_provider: openjdk
      java_type: jdk
      java_version: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las &amp;ldquo;pre-tasks&amp;rdquo; se necesitan para configurar el paquete &amp;ldquo;sudo&amp;rdquo; y poder
configurar &amp;ldquo;tty&amp;rdquo; en el contenedos. Esto se requiere cuando ejecutar un
&amp;ldquo;playbook&amp;rdquo; con el parámetro: &amp;ldquo;become&amp;rdquo;, que ejecuta un comando como &amp;ldquo;sudo&amp;rdquo;.
Luego se ejecuta el rol como en cualquier nodo:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ ansible-playbook provisioning.yml -vvvv
Using /home/jeqo/dev/jeqo/poc-ansible-docker/ansible.cfg as config file
Loaded callback default of &lt;span style=&#34;color: #008000&#34;&gt;type&lt;/span&gt; stdout, v2.0
&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; plays in provisioning.yml

PLAY ***************************************************************************

TASK &lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;setup&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt; *******************************************************************
ESTABLISH DOCKER CONNECTION FOR USER: None
&amp;lt;poccontainer&amp;gt; EXEC &lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;/usr/bin/docker&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;exec&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;, u&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;poccontainer&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;/bin/sh&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;/bin/sh -c \&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;umask&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;22&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
mkdir -p &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;` echo &lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;$HOME&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729 `&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
&lt;span style=&#34;color: #008000&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;` echo &lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;$HOME&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729 `&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;]&lt;/span&gt;
&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;lt;poccontainer&amp;gt; PUT /tmp/tmpNCOaxi TO /root/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729/setup&lt;/span&gt;
&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;lt;poccontainer&amp;gt; EXEC [&amp;#39;&lt;/span&gt;/usr/bin/docker&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;exec&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;-i&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, u&amp;#39;&lt;/span&gt;poccontainer&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;/bin/sh&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;-c&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39;, u&amp;#39;&lt;/span&gt;/bin/sh -c &lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt;LANG&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;en_US.UTF-8 
&lt;span style=&#34;color: #19177C&#34;&gt;LC_ALL&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;en_US.UTF-8 &lt;span style=&#34;color: #19177C&#34;&gt;LC_MESSAGES&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;en_US.UTF-8 /usr/bin/python /root/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729/setup; 
rm -rf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;/root/.ansible/tmp/ansible-tmp-1459355431.02-32251179247729/&amp;quot;&lt;/span&gt; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;#39;&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt;
ok: &lt;span style=&#34;color: #666666&#34;&gt;[&lt;/span&gt;poccontainer&lt;span style=&#34;color: #666666&#34;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Estos ejemplos muestran cual versátil es Ansible, usando roles y tipos de
conexión. Pero hay más plataformas donde Ansible puede ser utilizada, como AWS:
&lt;a href=&#34;https://aws.amazon.com/blogs/apn/getting-started-with-ansible-and-dynamic-amazon-ec2-inventory-management/&#34;&gt;https://aws.amazon.com/blogs/apn/getting-started-with-ansible-and-dynamic-amazon-ec2-inventory-management/&lt;/a&gt;
y otras plataformas en la nube:
&lt;a href=&#34;http://docs.ansible.com/ansible/list_of_cloud_modules.html&#34;&gt;http://docs.ansible.com/ansible/list_of_cloud_modules.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Una posible pregunta puede ser: ¿Puede Ansible reemplazar los Dockerfile?
Puede ser, depende de ti. Los Dockerfile son bastante sencillos y solo
funcionan en Docker. Los Dockerfile también tiene una característica interesante
que crea una imagen en cada paso de ejecución, lo que hace que la distribución
de imágenes sea más sencilla. Esto falta aún en Ansible, donde los comandos
se ejecutan sobre un contenedor en ejecución. En Ansible también está faltando
las opciones de &amp;ldquo;commit&amp;rdquo; y &amp;ldquo;push&amp;rdquo; en Docker, pero esto se puede reemplazar
facilmente así:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: 127.0.0.1
  connection: local
  tasks:
    - name: commit
      command: docker commit poccontainer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin embargo, Ansible también tiene un módulo para ejecutar Dockerfiles:
&lt;a href=&#34;http://docs.ansible.com/ansible/docker_image_module.html&#34;&gt;http://docs.ansible.com/ansible/docker_image_module.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Espero que esto les ayude a utilizar Ansible y Docker.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Imagen de Oracle SOA Suite 12c en Docker</title>
            <link>https://jeqo.github.io/es/post/2015-09-04-oracle-soa-12c-packer-docker-hub/</link>
            <pubDate>Fri, 04 Sep 2015 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2015-09-04-oracle-soa-12c-packer-docker-hub/</guid>
            <description>

&lt;p&gt;Luego de encontrar algunas limitaciones en la construcción de una imagen en
Docker con Oracle SOA Suite 12c instalado usando Dockerfiles (como acceso
a volumenes, tamaño de filesystem por defecto), he investigado como
mejorar este proceso, y he encontrado &lt;a href=&#34;https://packer.io/&#34;&gt;Packer&lt;/a&gt;
(del mismo equipo que creo Vagrant, Hashicorp).&lt;/p&gt;

&lt;p&gt;Para obtener mayor información sobre porqué utilizar Packer en vez de
Dockerfiles, &lt;a href=&#34;http://mmckeen.net/blog/2013/12/27/advanced-docker-provisioning-with-packer/&#34;&gt;ir aquí&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;También he movido el directory &lt;a href=&#34;https://github.com/jeqo/oracle-docker/tree/master/OracleSOA&#34;&gt;OracleSOA&lt;/a&gt;
que cree sobre el repositorio de Oracle Docker &lt;a href=&#34;https://github.com/oracle/docker&#34;&gt;oracle-docker&lt;/a&gt;
hacia un repositorio independiente: &lt;a href=&#34;https://github.com/jeqo/oracle-soa-12c-docker&#34;&gt;github.com/jeqo/oracle-soa-12c-docker&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mejoras&#34;&gt;Mejoras&lt;/h2&gt;

&lt;p&gt;Basicamente, los scripts de Dockerfile fueron transformados en shell scripts
y son invocados desde Packer en la etapa de provisionamiento&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;provisioners&amp;quot;: [
    {
      &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
      &amp;quot;scripts&amp;quot;: [
        &amp;quot;scripts/create-user.sh&amp;quot;
      ]
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;file&amp;quot;,
      &amp;quot;source&amp;quot;: &amp;quot;./files/&amp;quot;,
      &amp;quot;destination&amp;quot;: &amp;quot;/u01/&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
      &amp;quot;scripts&amp;quot;: [
        &amp;quot;scripts/install-java.sh&amp;quot;
      ],
      &amp;quot;environment_vars&amp;quot;: [
        &amp;quot;JAVA_RPM=/data/{{user `java_rpm`}}&amp;quot;
      ]
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
      &amp;quot;scripts&amp;quot;: [
        &amp;quot;scripts/install-soa.sh&amp;quot;
      ],
      &amp;quot;environment_vars&amp;quot;: [
        &amp;quot;SOA_ZIP=/data/{{user `soa_zip`}}&amp;quot;,
        &amp;quot;SOA_PKG={{user `soa_pkg`}}&amp;quot;,
        &amp;quot;SOA_PKG2={{user `soa_pkg2`}}&amp;quot;,
        &amp;quot;JAVA_HOME=/usr/java/default&amp;quot;,
        &amp;quot;MW_HOME=/u01/oracle/soa&amp;quot;
      ]
    }
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luego del provisionamiento exitoso, se procesa la imagen para
guardarla en Docker Hub:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;post-processors&amp;quot;: [
    [
      {
        &amp;quot;type&amp;quot;: &amp;quot;docker-tag&amp;quot;,
        &amp;quot;repository&amp;quot;: &amp;quot;jeqo/oracle-soa-12c&amp;quot;,
        &amp;quot;tag&amp;quot;: &amp;quot;12.1.3-dev&amp;quot;
      },
      &amp;quot;docker-push&amp;quot;
    ]
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Realmente la configuración en JSON es bastante simple y concreta.&lt;/p&gt;

&lt;p&gt;Una vez que la imagen esta cargada en Docker Hub, se puede utilizar
la herramienta preferida: Docker, Dockerfiles, o Vagrant, para crear un
dominio sobre la imagen creada. &lt;a href=&#34;https://github.com/jeqo/oracle-soa-12c-docker/tree/master/samples/12c-domain&#34;&gt;Ejemplo&lt;/a&gt;
explicado en mi &lt;a href=&#34;http://jeqo.github.io/blog/devops/docker-image-oracle-soa-es/&#34;&gt;post anterior&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Integrar Java EE 7 y Kafka usando Avro y RxJava</title>
            <link>https://jeqo.github.io/es/post/2015-07-31-java-ee-rxjava-kafka-avro/</link>
            <pubDate>Fri, 31 Jul 2015 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2015-07-31-java-ee-rxjava-kafka-avro/</guid>
            <description>

&lt;p&gt;Hace poco decidi probar una rápida implementación entre aplicaciones
Java EE y RxJava/Kafka/Avro, para publicar/subscribirse a &amp;ldquo;topic messages&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Puedes ir directamente al &lt;a href=&#34;https://github.com/jeqo/java-ee-rxjava-kafka-avro&#34;&gt;código&lt;/a&gt;,
o revisar el enfoque que apliqué:&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;He estado realizando alguna pruebas de concepto con &lt;a href=&#34;http://kafka.apache.org/&#34;&gt;Kafka&lt;/a&gt;
seducido por los beneficios que propone (rapidez, escalabilidad, y funcionar como
una fuente de eventos durable) para implementar una propagación de eventos
usando el patrón &amp;ldquo;Publish/Subscribe&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;En estos momentos que estoy escribiendo esta entrada del blog, me he dado cuenta
que las APIs para acceder a Kafka están en constante evolución y volviéndose
más simples de utilizar, y no ha sido fácil encontrar un ejemplo con la versión
actual. Estoy utilizando el &lt;strong&gt;release 0.8.2.1&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Logré encontrar este tutorial sobre como utilizar las APIs para &lt;em&gt;publicar&lt;/em&gt;
y &lt;em&gt;suscribirse&lt;/em&gt; a mensajes: &lt;a href=&#34;https://github.com/mdkhanga/my-blog-code&#34;&gt;https://github.com/mdkhanga/my-blog-code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kafka soporta 2 tipos de mensajes : &lt;em&gt;Strings&lt;/em&gt; and &lt;em&gt;byte[]&lt;/em&gt;. Luego de hacer
algunas pruebas con String, requería enviar POJOs como mensajes. Y encontré
otro proyecto de Apache: &lt;a href=&#34;https://avro.apache.org&#34;&gt;Avro&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Utilizando los tutoriales de Avro (&lt;a href=&#34;https://avro.apache.org/docs/current/gettingstartedjava.html&#34;&gt;https://avro.apache.org/docs/current/gettingstartedjava.html&lt;/a&gt;)
y otras fuentes: (&lt;a href=&#34;https://github.com/wpm/AvroExample&#34;&gt;https://github.com/wpm/AvroExample&lt;/a&gt;)
Encontre como Serializar/Deserializar POJO de una forma eficiente, sin necesidad
de persistir archivos en disco, solo manteniendolos como ByteStreams.&lt;/p&gt;

&lt;p&gt;En este punto tengo Eventos, definidos por &lt;a href=&#34;https://avro.apache.org/docs/current/spec.html#schema_record&#34;&gt;esquemas de Avro&lt;/a&gt;,
y APIs de Kafka listo para publicar y suscribirse a &amp;ldquo;topics&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Finalmente, quiero agregar esta características a mi aplicación Java EE 7.&lt;/p&gt;

&lt;p&gt;Primero, usando CDI, fue sencillo inyectar un &amp;ldquo;Producer&amp;rdquo; y publicar mensajes,
pero cuando se necesita consumir mensajes, el enfoque cambia. Ya no se trata
de enviar mensajes, pero consumir un &amp;ldquo;stream&amp;rdquo; de eventos. Así llegue a encontrarme
con &lt;a href=&#34;https://github.com/ReactiveX/RxJava&#34;&gt;RxJava&lt;/a&gt; que aplica conceptos como
&lt;a href=&#34;http://reactivex.io/documentation/observable.html&#34;&gt;&lt;strong&gt;Observables&lt;/strong&gt;&lt;/a&gt; y &lt;strong&gt;Subscribers&lt;/strong&gt;
que cubre mis requerimientos: cada Kafka topic será un stream &amp;ldquo;observable&amp;rdquo; y
cada Consumer se suscribirá a este &amp;ldquo;observable&amp;rdquo;. Revisemos el código:&lt;/p&gt;

&lt;h2 id=&#34;sample-java-ee-app&#34;&gt;Sample Java EE App&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeqo/java-ee-rxjava-kafka-avro/releases/tag/v0.0.1&#34;&gt;Tag: v0.0.1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;El primer paso fue tener un par de operaciones REST, implementados con JAX-RS:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clients Resource: List (GET) and Add (POST) Clients&lt;/li&gt;
&lt;li&gt;Events Resource: List (GET) Client Added Events&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Path(&amp;quot;clients&amp;quot;)
public class ClientsResource {

    static List&amp;lt;String&amp;gt; clients = new ArrayList&amp;lt;&amp;gt;();

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List&amp;lt;String&amp;gt; getClients() {
        return clients;
    }

    @POST
    public void addClient(String client) {
        clients.add(client);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luego de tener mi recurso &amp;ldquo;Clients&amp;rdquo; implementado, mi requerimiento es
propagar el evento &amp;ldquo;ClientAddedEvent&amp;rdquo; y listarlo en el recurso Events.&lt;/p&gt;

&lt;h2 id=&#34;serialización-y-deserialización-de-eventos&#34;&gt;Serialización y Deserialización de Eventos&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeqo/java-ee-rxjava-kafka-avro/releases/tag/v0.0.2&#34;&gt;Tag: v0.0.2&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test() {
    ClientAddedEvent event = ClientAddedEvent.newBuilder()
            .setName(&amp;quot;jeqo&amp;quot;)
            .setCreated(new Date().getTime())
            .build();
    byte[] eventSerialized = serializer.serialize(event);
    ClientAddedEvent eventDeserialized = deserializer.deserialize(eventSerialized);
    assertEquals(event, eventDeserialized);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El event ClientAddedEvent es definido usando el formato Avro JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;namespace&amp;quot;: &amp;quot;com.jeqo.samples.eventsource.event&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;record&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;ClientAddedEvent&amp;quot;,
    &amp;quot;fields&amp;quot;: [
        {&amp;quot;name&amp;quot;: &amp;quot;name&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;},
        {&amp;quot;name&amp;quot;: &amp;quot;created&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;long&amp;quot;}
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agregando el siguiente plugin de Maven, la clase  &lt;em&gt;ClientAddedEvent&lt;/em&gt; se
creará cada vez que el proyecto sea construido:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.avro&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;avro-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;schema&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;sourceDirectory&amp;gt;${project.basedir}/src/main/avro/&amp;lt;/sourceDirectory&amp;gt;
                        &amp;lt;outputDirectory&amp;gt;${project.basedir}/src/main/java/&amp;lt;/outputDirectory&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para serializar Avro records, de POJO a Byte Array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EventSerializer&amp;lt;T extends SpecificRecordBase&amp;gt; {

    public byte[] serialize(T record) {
        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
            Encoder encoder = EncoderFactory.get().binaryEncoder(out, null);
            new SpecificDatumWriter&amp;lt;&amp;gt;(record.getSchema()).write(record, encoder);
            encoder.flush();
            return out.toByteArray();
        } catch (IOException ex) {
            throw new RuntimeException(&amp;quot;Error serializing event&amp;quot;, ex);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y viceversa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EventDeserializer&amp;lt;T extends SpecificRecordBase&amp;gt; {

    private final Class&amp;lt;T&amp;gt; type;

    public EventDeserializer(Class&amp;lt;T&amp;gt; type) {
        this.type = type;
    }

    public T deserialize(byte[] recordSerialized) {
        try {
            return new SpecificDatumReader&amp;lt;&amp;gt;(type).read(
                    null,
                    DecoderFactory.get()
                    .binaryDecoder(recordSerialized, null)
            );
        } catch (IOException ex) {
            throw new RuntimeException(&amp;quot;Error deserializing event&amp;quot;, ex);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publicando-y-consumiendo-eventos-desde-kafka-rxjava&#34;&gt;Publicando y consumiendo eventos desde Kafka/RxJava&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeqo/java-ee-rxjava-kafka-avro/releases/tag/v0.0.3&#34;&gt;Tag: v0.0.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Primero, definamos un par de interfaces, EventServer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface EventServer&amp;lt;T&amp;gt; {

    public Observable&amp;lt;T&amp;gt; consume();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y EventProducer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface EventProducer&amp;lt;T&amp;gt; {

    public void publish(T message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luego, implementemos estas interfaces con Kafka APIs.&lt;/p&gt;

&lt;p&gt;Para publicar mensajes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void publish(T message) {
    // Produce a new Kafka record
    ProducerRecord&amp;lt;String, byte[]&amp;gt; data = new ProducerRecord&amp;lt;&amp;gt;(
            message.getClass().getSimpleName(),
            serializer.serialize(message)
    );

    // Publish this new record, waiting for acknowledge from Kafka
    Future&amp;lt;RecordMetadata&amp;gt; rs = producerProvider.producer()
            .send(data, (RecordMetadata recordMetadata, Exception e) -&amp;gt; {
                LOGGER.log(Level.INFO, &amp;quot;Received ack for partition={0} offset = {1}&amp;quot;, new Object[]{recordMetadata.partition(), recordMetadata.offset()});
            });

    try {
        RecordMetadata rm = rs.get();

        LOGGER.log(Level.INFO, &amp;quot;Kafka Record Metadata: partition = {0} offset ={1}&amp;quot;, new Object[]{rm.partition(), rm.offset()});

    } catch (InterruptedException | ExecutionException e) {
        System.out.println(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y en KafkaEventServer, para instanciar un RxJava observable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Observable&amp;lt;T&amp;gt; consume() {
    return Observable.create(subscriber -&amp;gt; {
        try {
            LOGGER.log(Level.INFO, &amp;quot;Preparing Server for Event {0}&amp;quot;, type.getName());
            // It will observe one Topic
            Map&amp;lt;String, Integer&amp;gt; topicCountMap = new HashMap&amp;lt;&amp;gt;();
            topicCountMap.put(type.getSimpleName(), 1);

            // consumerProvider will instantiate a consumer that will create a KafkaStream
            Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt;&amp;gt; consumerMap
                    = consumerProvider.consumer()
                    .createMessageStreams(topicCountMap);

            // then I will ask for the Stream from my topic, defined by Avro Record Class name
            List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt; streams = consumerMap
                    .get(type.getSimpleName());

            KafkaStream&amp;lt;byte[], byte[]&amp;gt; stream = streams.get(0);

            ConsumerIterator&amp;lt;byte[], byte[]&amp;gt; it = stream.iterator();

            // on each message published on topic, I will let the subscriber receive the new message
            while (it.hasNext()) {
                subscriber.onNext(
                        deserializer.deserialize(it.next().message())
                );
            }
        } catch (Exception ex) {
            subscriber.onError(ex);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se puede validar la clase *Provider para observar como se genera la conexión
con Kafka, tanto para el Publisher como para el Subscriber.&lt;/p&gt;

&lt;p&gt;En el tag v0.0.3 se puede ejecutar cada clase (KafkaEventServer and KafkaEventProducer)
para validar que el servidor Kafka esta trabajando correctamente.&lt;/p&gt;

&lt;h2 id=&#34;uniendo-todo&#34;&gt;Uniendo todo&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeqo/java-ee-rxjava-kafka-avro/releases/tag/v0.1.0&#34;&gt;Tag: v0.1.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finalmente, vamos a integrar la aplicación Java EE interacción con la nuestra
fuente de eventos (Kafka):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ApplicationScoped
public class ClientAddedEventProducer extends KafkaEventProducer&amp;lt;ClientAddedEvent&amp;gt; {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La anotación @ApplicationScoped de CDI indica que esta clase se instanciará como
&lt;em&gt;&amp;ldquo;singleton&amp;rdquo;&lt;/em&gt; y podrá ser inyectada:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClientsResource {

    @Inject
    ClientAddedEventProducer eventProducer;

    //code

    @POST
    public void addClient(String client) {
        clients.add(client);
        //Publishing events
        eventProducer.publish(
                ClientAddedEvent.newBuilder()
                .setName(client)
                .setCreated(new Date().getTime())
                .build()
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luego para instanciar el &lt;em&gt;Subscriber&lt;/em&gt; (Creo que es la parte más importante:
como &lt;strong&gt;reaccionar&lt;/strong&gt; a eventos? ):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Extending Subscriber RxJava class to listen Observables
@ApplicationScoped
public class ClientAddedEventSubscriber extends Subscriber&amp;lt;ClientAddedEvent&amp;gt; {

    static final Logger LOGGER = Logger.getLogger(ClientAddedEventSubscriber.class.getName());

    // This will add a new thread to our pool, to subscribe to our Observable
    @Resource(name = &amp;quot;DefaultManagedExecutorService&amp;quot;)
    private ManagedExecutorService executor;

    @Inject
    private KafkaConsumerProvider consumerProvider;

    private Subscription subscription;

    // Run this on server startup, using CDI annotations
    public void init(@Observes @Initialized(ApplicationScoped.class) Object init) {
        LOGGER.log(Level.INFO, &amp;quot;Starting subscription&amp;quot;);
        subscription = new KafkaEventServer&amp;lt;&amp;gt;(
                ClientAddedEvent.class,
                consumerProvider,
                executor
        ).consume().subscribe(this);
    }

    public void destroy(@Observes @Destroyed(ApplicationScoped.class) Object init) {
        subscription.unsubscribe();
    }

    @Override
    public void onCompleted() {
        throw new UnsupportedOperationException(&amp;quot;Not supported yet.&amp;quot;);
    }

    @Override
    public void onError(Throwable e) {
        throw new UnsupportedOperationException(&amp;quot;Not supported yet.&amp;quot;);
    }

    @Override
    public void onNext(ClientAddedEvent t) {
        LOGGER.log(Level.INFO, &amp;quot;Event received {0}&amp;quot;, t);
        // How we will react to events:
        EventsResource.events.add(
                &amp;quot;Client Added: &amp;quot; + t.getName() + &amp;quot; at &amp;quot; + new Date(t.getCreated())
        );
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Oracle Fusion Middleware Chef Cookbook - Nueva versión!</title>
            <link>https://jeqo.github.io/es/post/2015-07-21-chef-cookbook-oracle-fmw-0-2-0/</link>
            <pubDate>Tue, 21 Jul 2015 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2015-07-21-chef-cookbook-oracle-fmw-0-2-0/</guid>
            <description>&lt;p&gt;Ayer cargué una nueva versión (0.2.0) de mi Oracle Fusion Middleware Cookbook
compartido en &lt;a href=&#34;https://supermarket.chef.io/cookbooks/oracle-fmw&#34;&gt;Chef Supermarket&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Este nuevo release incluye:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Soporte para la instalación de Oracle SOA Suite 12c Quickstart&lt;/li&gt;
&lt;li&gt;Soporte para la instalación y creación de dominios con Oracle SOA/OSB Suite 11g&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pueden encontrar ejemplos de uso en este repositorio: &lt;a href=&#34;https://github.com/jeqo/chef-repo&#34;&gt;https://github.com/jeqo/chef-repo&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Oracle SOA Suite 12c sobre Docker</title>
            <link>https://jeqo.github.io/es/post/2015-04-01-docker-image-oracle-soa/</link>
            <pubDate>Wed, 01 Apr 2015 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2015-04-01-docker-image-oracle-soa/</guid>
            <description>

&lt;p&gt;Buenas noticias llegaron desde Oracle hace un par de semanas: &lt;a href=&#34;https://blogs.oracle.com/WebLogicServer/entry/oracle_weblogic_server_now_running&#34;&gt;Oracle WebLogic Server es ahora soportado en  Docker!&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;es&#34;&gt;&lt;p&gt;I&amp;#39;m glad we announced support for &lt;a href=&#34;https://twitter.com/OracleWebLogic&#34;&gt;@OracleWebLogic&lt;/a&gt; on &lt;a href=&#34;https://twitter.com/docker&#34;&gt;@Docker&lt;/a&gt; last week, not today :-) &lt;a href=&#34;https://t.co/6E9UxrgY3n&#34;&gt;https://t.co/6E9UxrgY3n&lt;/a&gt;&lt;/p&gt;&amp;mdash; Bruno Borges  (@brunoborges) &lt;a href=&#34;https://twitter.com/brunoborges/status/583252433343758336&#34;&gt;abril 1, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Esto es muy emocionante. &lt;strong&gt;Docker&lt;/strong&gt; es una nueva tecnología que propone una nueva forma de virtualización
a través de contenedores (OS, Configurations, Platform, Application) Para &lt;a href=&#34;https://www.docker.com/whatisdocker/&#34;&gt;más información acerca de Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bueno, WebLogic sobre Docker es genial, pero me he propuesto ir unos pasos más adelante y &lt;em&gt;Dockerize&lt;/em&gt; los
productos de &lt;strong&gt;SOA&lt;/strong&gt; y &lt;strong&gt;BPM&lt;/strong&gt;  (como &lt;a href=&#34;https://guidoschmutz.wordpress.com/2015/03/29/installing-oracle-stream-explorer-in-a-docker-image/&#34;&gt;Guido Schmitz hizo con  Oracle Stream Explorer&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;es&#34;&gt;&lt;p&gt;Just published my latest blog “Providing Oracle Stream Explorer environment using Docker”. &lt;a href=&#34;https://twitter.com/hashtag/oracle?src=hash&#34;&gt;#oracle&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/StreamExplorer?src=hash&#34;&gt;#StreamExplorer&lt;/a&gt; &lt;a href=&#34;http://t.co/WNFGCmFVca&#34;&gt;http://t.co/WNFGCmFVca&lt;/a&gt;&lt;/p&gt;&amp;mdash; gschmutz (@gschmutz) &lt;a href=&#34;https://twitter.com/gschmutz/status/582232826772357120&#34;&gt;marzo 29, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;He utilizado el &lt;a href=&#34;http://github.com/oracle/docker&#34;&gt;repositorio de Oracle&lt;/a&gt; como base para crear una
imagen con Oracle SOA Suite 12c instalado, y una configuración para utilizar esa imagen en la
creación de otro contenedor con un dominio listo para ejecutar.&lt;/p&gt;

&lt;h2 id=&#34;obtener-el-repositorio&#34;&gt;Obtener el repositorio&lt;/h2&gt;

&lt;p&gt;Para probar esta entrada del blog, debe tener instalado &lt;a href=&#34;https://docs.docker.com/&#34;&gt;Docker en su máquina&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El repositorio se encuentra ubicado en: &lt;a href=&#34;http://github.com/jeqo/oracle-docker&#34;&gt;http://github.com/jeqo/oracle-docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mi contribución está en la carpeta &lt;a href=&#34;https://github.com/jeqo/oracle-docker/tree/master/OracleSOA&#34;&gt;&amp;lsquo;OracleSOA&amp;rsquo;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;creación-de-la-imagen-con-oracle-soa-suite-12c&#34;&gt;Creación de la imagen con Oracle SOA Suite 12c&lt;/h2&gt;

&lt;p&gt;Primero se deben &lt;a href=&#34;http://www.oracle.com/technetwork/middleware/soasuite/downloads/index.html&#34;&gt;descargar los instaladores de Oracle SOA Suite 12c Quick Start&lt;/a&gt;,
y colocarlos en la carpeta OracleSOA/dockerfiles/12.1.3. De la misma forma
 &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&#34;&gt;descargar Java Development Kit 7&lt;/a&gt;,
 y colocarlo en el mismo folder.&lt;/p&gt;

&lt;p&gt;Abrir un terminal en el directorio &lt;em&gt;OracleSOA&lt;/em&gt;, ir a dockerfiles, y ejecutar el script &lt;em&gt;buildDockerImage.sh&lt;/em&gt; con el argumento &lt;em&gt;-d&lt;/em&gt; que indica que es la versión de desarrollo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh buildDockerImage.sh -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta ejecución crear una imagen llamada: &lt;strong&gt;oracle/soa:12.1.3-dev&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;dockerize-un-dominio-con-soa-suite&#34;&gt;Dockerize un dominio con SOA Suite&lt;/h2&gt;

&lt;p&gt;Ahora que tenemos una imagen Docker con SOA instalado, podemos reutilizarla para
crear dominios con WLST.&lt;/p&gt;

&lt;p&gt;Existe un ejemplo de este procedimiento en &lt;em&gt;OracleSOA/samples&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para ejecutarlo, ir a &lt;em&gt;OracleSOA/samples/12c-domain&lt;/em&gt; y correr el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t mysoa .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esto debe crear un imagen &lt;em&gt;mysoa&lt;/em&gt; que contiene un Compact Domain instalado en: &lt;em&gt;/u01/oracle/work/domains/soa-domain&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eso es todo! Para crear un contenedor desde la imagen, ejecutar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -i -t mysoa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BPM sobre Docker&lt;/li&gt;
&lt;li&gt;Publicar imagenes en Docker Hub Registry&lt;/li&gt;
&lt;li&gt;Dominios Extendidos sobre Docker: Usar una base de datos Oracle Database para instalar Oracle SOA/BPM Schemas&lt;/li&gt;
&lt;li&gt;SOA/BPM Cluster sobre Docker containers&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Oracle BPM 12c sobre AWS EC2 usando Vagrant y Chef</title>
            <link>https://jeqo.github.io/es/post/2014-12-11-run-bpm-12c-aws/</link>
            <pubDate>Thu, 11 Dec 2014 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2014-12-11-run-bpm-12c-aws/</guid>
            <description>

&lt;p&gt;En esta entrada mostraré el procedimiento que utilicé para crear
instancias en Amazon Web Service EC2, con Oracle BPM 12c instalado y
un dominio provisionado.&lt;/p&gt;

&lt;p&gt;Este procedimiento se realizo en los siguientes pasos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Crear una instancia en AWS EC2 (con Vagrant)&lt;/li&gt;
&lt;li&gt;Conectarse a una instancia NFS para obtener instaladores (con Chef)&lt;/li&gt;
&lt;li&gt;Instalar Oracle BPM 12c Quickstart y crear Dominio (con Chef)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/jeqo/oracle-bpm-12c-aws&#34;&gt;https://github.com/jeqo/oracle-bpm-12c-aws&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;crear-una-instancia-en-aws-ec2&#34;&gt;Crear una instancia en AWS EC2&lt;/h2&gt;

&lt;p&gt;He creado una instancia Red Hat usando Vagrant. Esta instancia debe estar conectada
a una instancia NFS que tiene los instaladores de Oracle (esta fue creada
  en esta &lt;a href=&#34;http://jeqo.github.io/blog/devops/create-nfs-instance-aws-es/&#34;&gt;entrada&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Esta es la instancia NFS:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/2014-12-11-run-bpm-12c-aws/2014-12-11_0836.png&#34; alt=&#34;Instancia NFS&#34; title=&#34;NFS Instance&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Y el directorio &amp;ldquo;/data&amp;rdquo; esta compartido. Incluye los instaladores de Oracle DB XE 11g y BPM 12c:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/2014-12-11-run-bpm-12c-aws/2014-12-11_0841.png&#34; alt=&#34;Directorios NFS&#34; title=&#34;NFS directories&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;configuración-en-vagrant&#34;&gt;Configuración en Vagrant&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/jeqo/62b74a9ed65d575d91b4&#34;&gt;Gist&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;{% gist 62b74a9ed65d575d91b4 Vagrantfile &amp;gt;}}&lt;/p&gt;

&lt;p&gt;Ejecutar el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vagrant up --provider=aws
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conectarse-a-la-instancia-nfs&#34;&gt;Conectarse a la instancia NFS&lt;/h3&gt;

&lt;p&gt;Esta es la primera receta Chef que será ejecutada:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;...
  chef.add_role &amp;quot;nfs-client&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utilizando el rol Chef:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot; : &amp;quot;nfs-client&amp;quot;,
  &amp;quot;description&amp;quot; : &amp;quot;Role applied to the system that should be an NFS client tools.&amp;quot;,
  &amp;quot;json_class&amp;quot; : &amp;quot;Chef::Role&amp;quot;,
  &amp;quot;default_attributes&amp;quot; : {
    &amp;quot;nfs-client&amp;quot; : {
      &amp;quot;server-host&amp;quot; : &amp;quot;localhost&amp;quot;,
      &amp;quot;local-directory&amp;quot; : &amp;quot;/data&amp;quot;,
      &amp;quot;remote-directory&amp;quot; : &amp;quot;/data&amp;quot;
    }
  },
  &amp;quot;run_list&amp;quot; : [
    &amp;quot;recipe[nfs-utils::nfs-client]&amp;quot;
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para actualizar el server-host desde su configuración de Vagrant, agregar las
siguientes líneas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;...
chef.json = {
  &amp;quot;nfs-client&amp;quot; =&amp;gt; {
    &amp;quot;server-host&amp;quot; =&amp;gt; &amp;quot;123.1.1.12&amp;quot;
  },
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y cuando la instancia sea creada, un nuevo directorio &amp;ldquo;/data&amp;rdquo; se sincronizará.&lt;/p&gt;

&lt;h2 id=&#34;instalación-de-oracle-bpm-12c-quickstart&#34;&gt;Instalación de Oracle BPM 12c Quickstart&lt;/h2&gt;

&lt;p&gt;Para instalar BPM, se debe utilizar el &lt;a href=&#34;https://supermarket.chef.io/cookbooks/oracle-fmw&#34;&gt;cookbook &amp;ldquo;oracle-fmw&amp;rdquo;&lt;/a&gt;
compartido en Chef Supermarket. Este esta explicador en &lt;a href=&#34;http://jeqo.github.io/blog/devops/chef-cookbook-oracle-fmw-12c-es/&#34;&gt;esta entrada&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;La configuración de Vagrant invoca el provisionamiento con Chef:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot; : &amp;quot;demo-bpm_bam-12c&amp;quot;,
  &amp;quot;json_class&amp;quot; : &amp;quot;Chef::Role&amp;quot;,
  &amp;quot;default_attributes&amp;quot; : {
    &amp;quot;domain-12c&amp;quot;: {
      &amp;quot;name&amp;quot;: &amp;quot;demo-bpm_bam-domain&amp;quot;,
      &amp;quot;mode&amp;quot;: &amp;quot;Compact&amp;quot;,
      &amp;quot;apps&amp;quot;: [
        {&amp;quot;name&amp;quot; : &amp;quot;SOA&amp;quot;, &amp;quot;enabled&amp;quot; : true},
        {&amp;quot;name&amp;quot; : &amp;quot;BPM&amp;quot;, &amp;quot;enabled&amp;quot; : true},
        {&amp;quot;name&amp;quot; : &amp;quot;BAM&amp;quot;, &amp;quot;enabled&amp;quot; : true},
        {&amp;quot;name&amp;quot; : &amp;quot;OSB&amp;quot;, &amp;quot;enabled&amp;quot; : false}
      ],
      &amp;quot;machines&amp;quot;: [
      ],
      &amp;quot;admin_server&amp;quot;: {
        &amp;quot;base_name&amp;quot; : &amp;quot;AdminServer&amp;quot;,
        &amp;quot;new_name&amp;quot; : &amp;quot;bpm_bpm-server&amp;quot;,
        &amp;quot;port&amp;quot; : &amp;quot;7001&amp;quot;
      },
      &amp;quot;managed_servers&amp;quot;: [
      ],
      &amp;quot;db_repo_host&amp;quot;: &amp;quot;localhost&amp;quot;,
      &amp;quot;db_repo_port&amp;quot;: &amp;quot;1521&amp;quot;,
      &amp;quot;db_repo_sid&amp;quot;: &amp;quot;xe&amp;quot;,
      &amp;quot;db_repo_prefix&amp;quot;: &amp;quot;DEMO&amp;quot;,
      &amp;quot;db_repo_password&amp;quot;: &amp;quot;welcome1&amp;quot;
    },
    &amp;quot;rcu-12c&amp;quot;: {
      &amp;quot;db_schema_prefix&amp;quot;: &amp;quot;DEMO&amp;quot;,
      &amp;quot;db_dba_user&amp;quot;: &amp;quot;SYS&amp;quot;,
      &amp;quot;db_dba_role&amp;quot;: &amp;quot;SYSDBA&amp;quot;,
      &amp;quot;db_dba_password&amp;quot;: &amp;quot;welcome1&amp;quot;,
      &amp;quot;db_schemas_password&amp;quot;: &amp;quot;welcome1&amp;quot;,
      &amp;quot;db_hostname&amp;quot;: &amp;quot;localhost&amp;quot;,
      &amp;quot;db_port&amp;quot;: &amp;quot;1521&amp;quot;,
      &amp;quot;db_service&amp;quot;: &amp;quot;xe&amp;quot;,
      &amp;quot;components&amp;quot;: [
        &amp;quot;SOAINFRA&amp;quot;,
        &amp;quot;OPSS&amp;quot;,
        &amp;quot;IAU&amp;quot;,
        &amp;quot;MDS&amp;quot;,
        &amp;quot;WLS&amp;quot;,
        &amp;quot;UCSUMS&amp;quot;,
        &amp;quot;IAU_APPEND&amp;quot;,
        &amp;quot;IAU_VIEWER&amp;quot;
      ]
    }
  },
  &amp;quot;run_list&amp;quot; : [
    &amp;quot;recipe[oracle-fmw::install-bpm_qs-12c]&amp;quot;,
    &amp;quot;recipe[oracle-fmw::create-rcu_repository-12c]&amp;quot;,
    &amp;quot;recipe[oracle-fmw::create-domain-12c]&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Incluye la llamada a 3 recetas: &amp;ldquo;install-bpm_qs-12c&amp;rdquo; , &amp;ldquo;create-rcu_repository-12c&amp;rdquo;,
&amp;ldquo;create-domain-12c&amp;rdquo;, incluyendo la información del dominio (&amp;ldquo;domain-12c&amp;rdquo;), y RCU (&amp;ldquo;rcu-12c&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Este proceso toma cerca de 30 min. aprox.&lt;/p&gt;

&lt;p&gt;Una vez finalizado, debe poder acceder con el usuario de sistema operativo &amp;ldquo;oracle-fmw&amp;rdquo; (password: welcome1), e iniciar el servidor:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/2014-12-11-run-bpm-12c-aws/2014-12-11_0930.png&#34; alt=&#34;Start server&#34; title=&#34;Stating WebLogic Server&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;raw/gh-pages/images/2014-12-11-run-bpm-12c-aws/2014-12-11_0931.png&#34; alt=&#34;Server started&#34; title=&#34;WebLogic Server with BPM started&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Eso es todo :).&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Chef Cookbook para Oracle Fusion Middleware 12c</title>
            <link>https://jeqo.github.io/es/post/2014-12-09-chef-cookbook-oracle-fmw-12c/</link>
            <pubDate>Tue, 09 Dec 2014 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2014-12-09-chef-cookbook-oracle-fmw-12c/</guid>
            <description>

&lt;p&gt;Las herramientas de provisionamiento de software han cambiado la forma de
crear ambientes: Cuánto tiempo que se toma para instalar Sistema Operativo,
base de datos, configurar la plataforma, desplegar aplicaciones? Pueden
ser días, hasta semanas. Ahora que se pueden transladar estos pasos en código,
este proceso se ve transformado en horas, hasta minutos.&lt;/p&gt;

&lt;p&gt;En esta entrada voy a mostrar como provisionar un Dominio WebLogic con Oracle
SOA Suite 12c, utilizando un &lt;em&gt;Chef cookbook&lt;/em&gt; que he compartido en &lt;a href=&#34;http://supermarket.chef.io&#34;&gt;Chef Supermarket&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;provisionamiento-con-chef&#34;&gt;Provisionamiento con Chef&lt;/h2&gt;

&lt;p&gt;Chef es una herramienta para configurar software, basada en Ruby. Para mayor información
sobre como iniciar con Chef, &lt;a href=&#34;http://learn.chef.io/&#34;&gt;ir aquí&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;chef-cookbooks-y-recipes&#34;&gt;Chef Cookbooks y Recipes&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Chef Cookbooks&lt;/strong&gt; son grupos de &lt;strong&gt;Recipes&lt;/strong&gt; (o recetas), y una &lt;strong&gt;Recipe&lt;/strong&gt; es una
 secuencia de instrucciones llamadas &lt;strong&gt;Resources&lt;/strong&gt; (o recursos).
 &lt;em&gt;Directory, Execute, Service, Package&lt;/em&gt; son algunos recursos disponibles.&lt;/p&gt;

&lt;p&gt;Por ejemplo: Si uno quiere instalar un servidor HTTP Server, primero se debe instalar el recurso &lt;em&gt;Package&lt;/em&gt;, y luego iniciar el recurso &lt;em&gt;Service&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;oracle-fusion-middleware-cookbook&#34;&gt;Oracle Fusion Middleware Cookbook&lt;/h2&gt;

&lt;p&gt;He compartido este &amp;ldquo;Chef cookbook&amp;rdquo;: &lt;a href=&#34;https://supermarket.chef.io/cookbooks/oracle-fmw&#34;&gt;oracle-fmw&lt;/a&gt;.
La idea es tener un grupo de recetas para configurar ambientes con diferentes productos
de Oracle Fusion Middleware como: SOA, BPM, BAM, OSB, etc.&lt;/p&gt;

&lt;p&gt;En este primer release se incluyen las siguientes recetas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prepare-infrastructure-12c&lt;/strong&gt;: Crear los usuarios y grupos de Sistema Operativo, instala paquetes base
para la ejecución de futuros scripts de FMW.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;install-bpm_qs-12c&lt;/strong&gt;: Instala Oracle BPM 12c, que incluye los siguientes productos en la versión 12.1.3: JDeveloper, Oracle SOA, Oracle OSB, Oracle BAM, Oracle BAM and others.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;create-rcu_repository-12c&lt;/strong&gt;: Crea repositorios en base de datos con RCU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;create-domain-12c&lt;/strong&gt;: Crea un Dominio WebLogic con estos productos: SOA, BAM, BPM, OSB.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En una siguiente entrada mostraré como utilizar este &amp;ldquo;cookbook&amp;rdquo;. Mientras tanto puede descargar, usar y compartir mejoras en &lt;a href=&#34;https://supermarket.chef.io/cookbooks/oracle-fmw&#34;&gt;Chef Supermarket&lt;/a&gt; y &lt;a href=&#34;https://github.com/jeqo/oracle-fmw&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Crear una instancia NFS en AWS usando Vagrant y Chef</title>
            <link>https://jeqo.github.io/es/post/2014-11-30-create-nfs-instance-aws/</link>
            <pubDate>Sun, 30 Nov 2014 00:00:00 UTC</pubDate>
            <author>Jorge Quilcate Otoya</author>
            <guid>https://jeqo.github.io/es/post/2014-11-30-create-nfs-instance-aws/</guid>
            <description>

&lt;p&gt;Estuve probando la creación de instancias en AWS EC2 para instalar productos de Oracle
Fusion Middleware, y encontré una restricción: Cómo descargar los instaladores si
quiero reutilizarlos en varias instancias? Cómo evitar un consumo alto
de ancho de banda? Y cómo hacer este procedimiento repetitivo?&lt;/p&gt;

&lt;p&gt;Entre varias soluciones, en este momento decidi aplicar : &lt;a href=&#34;https://theredblacktree.wordpress.com/2013/05/23/how-to-setup-a-amazon-aws-ec2-nfs-share/&#34;&gt;How to setup an Amazon AWS EC2 NFS Share&lt;/a&gt;.
Pero para hacerla reutilizable cree una configuración en Vagrant y Chef para provisionar
una instancia en AWS con NFS configurado: &lt;a href=&#34;https://github.com/jeqo/vagrant-aws-chef-nfs&#34;&gt;Git repository&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;qué-pasos-seguí&#34;&gt;Qué pasos seguí?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Instalar Vagrant (vagrant-aws y vagrant-omnibus) y Chef SDK&lt;/li&gt;
&lt;li&gt;Crear una cuenta para crear un &lt;a href=&#34;https://manage.opscode.com/&#34;&gt;Chef Server&lt;/a&gt; y cargar los &amp;ldquo;cookbooks&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Tener una &lt;a href=&#34;http://aws.amazon.com/&#34;&gt;AWS account&lt;/a&gt; para crear instancias de forma remota.&lt;/li&gt;
&lt;li&gt;Crear una configuración en Vagrant para tener una instancia con NFS&lt;/li&gt;
&lt;li&gt;Probar.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Este video muestra como utilizar la configuración del repositorio en GitHub:&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;//www.youtube.com/embed/gqhY82kdHh4&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
        </item>
        
    </channel>
</rss>
