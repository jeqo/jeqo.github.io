<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kafka on @jeqo</title><link>https://jeqo.github.io/tags/kafka/</link><description>Recent content in Kafka on @jeqo</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 24 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://jeqo.github.io/tags/kafka/index.xml" rel="self" type="application/rss+xml"/><item><title>Kafka Emulator CLI: Record and Reply Records considering time-distance</title><link>https://jeqo.github.io/posts/2022-08-24-kafka-cli-emulator/</link><pubDate>Wed, 24 Aug 2022 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2022-08-24-kafka-cli-emulator/</guid><description>Looking for alternative ways to reproduce time-based conditions in Kafka Streams applications —e.g. if you&amp;rsquo;re doing some sort of join or windowing based on time— I ended up creating a CLI tool to support a couple of features:
Record events from topics, including their timestamps and gap Replay events, including waiting periods between them SQLite is used a storage for recorded events, so events can be generated, updated, tweaked using SQL.</description></item><item><title>Piggyback on Kafka Connect Schemas to process Kafka records in a generic way</title><link>https://jeqo.github.io/notes/2022-08-24-kafka-connect-schema-serde/</link><pubDate>Wed, 24 Aug 2022 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2022-08-24-kafka-connect-schema-serde/</guid><description>When reading from/writing to Kafka topics, a serializer/deserializer (a.k.a SerDes) is needed to process record key and value bytes. Specific SerDes that turn bytes into specific objects (e.g. POJO) are used, unless a generic JSON object or Avro structure is used.
Kafka Connect has to deal with generic structures to apply message transformations and convert messages from external sources into Kafka records and vice-versa. It has a SchemaAndValue composed type that includes a Connect Schema type derived from Schema Registry or JSON Schema included in the payload, and a value object.</description></item><item><title>Getting started with Kafka quotas</title><link>https://jeqo.github.io/posts/2022-05-11-kafka-quotas/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2022-05-11-kafka-quotas/</guid><description>&lt;p>Kafka quotas have been around for a while since initial versions of the project — though not necessarily being enabled in most deployments that I have seen.&lt;/p>
&lt;p>This post shares some thoughts on how to start adopting quotas and gives some practical advice, and a bit of the history of quotas in the Kafka project.&lt;/p></description></item><item><title>Kafka client applications with GraalVM</title><link>https://jeqo.github.io/posts/2022-03-18-kafka-clients-graalvm/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2022-03-18-kafka-clients-graalvm/</guid><description>&lt;p>Shipping CLI binaries with Java hasn&amp;rsquo;t been the most user-friendly experience.
Java is required to be installed on the client-side, starting Java applications (e.g. executable JAR) tend to be slower than to binary applications.&lt;/p>
&lt;p>GraalVM, and specifically &lt;a href="https://www.graalvm.org/22.0/reference-manual/native-image/">native-image&lt;/a> tooling, is aimed to tackle most of these issues with Java by enable building native binaries from Java applications.&lt;/p>
&lt;p>Even though this has been supported for a while now, reflection and other practices require additional configurations that make this process either unsupported or very cumbersome to implement.&lt;/p>
&lt;p>With the arrival of new frameworks that target the benefits of GraalVM, like &lt;a href="https://micronaut.io/">Micronaut&lt;/a> and &lt;a href="https://quarkus.io/">Quarkus&lt;/a>, it started to be possible and simpler to implement applications that included Kafka clients, and package them as native binaries.&lt;/p>
&lt;p>This post is going to explore the steps to package &lt;em>vanilla&lt;/em> Kafka client applications —i.e. no framework— as native binaries.&lt;/p></description></item><item><title>Explore Kafka data with kcat, sqlite, and Datasette</title><link>https://jeqo.github.io/notes/2022-03-10-kcat-end-offset-and-datasette/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2022-03-10-kcat-end-offset-and-datasette/</guid><description>&lt;p>I have been playing with Datasette and sqlite for a bit, trying to collect and expose data efficiently for others to analyze.
Recently started finding use-cases to get data from Apache Kafka, and expose it quickly to analyze it.
Why not using Datasette?&lt;/p></description></item><item><title>Enable Certificate Revocation on Kafka clusters</title><link>https://jeqo.github.io/notes/2022-02-09-kafka-ssl-crl/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2022-02-09-kafka-ssl-crl/</guid><description>&lt;p>Recently I got a question on how to manage revoked SSL certificates in Kafka clusters.
With a proper Public Key Infrastructure, a Certificate Revocation List (CRL) can be available for clients to validate if a certificate is still valid regardless of its time-to-live.
For instance, if a private key has been compromised, then a certificate can be revoked before it&amp;rsquo;s valid date.&lt;/p></description></item><item><title>Changing Kafka Broker's rack</title><link>https://jeqo.github.io/notes/2021-12-10-kafka-change-rack/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2021-12-10-kafka-change-rack/</guid><description>&lt;p>Kafka broker configuration includes a &lt;code>rack&lt;/code> label to define the location of the broker.
This is useful when placing replicas across the cluster to ensure replicas are spread across locations &lt;em>as evenly as possible&lt;/em>.&lt;/p></description></item><item><title>Kafka data loss scenarios</title><link>https://jeqo.github.io/posts/2021-12-10-kafka-data-loss/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2021-12-10-kafka-data-loss/</guid><description>Kafka topic partitions are replicated across brokers. Data loss happens when the brokers where replicas are located are unavailable or have fully failed. The worst scenario — and where is no much to do — is when all the brokers fail; then no remediation is possible. Replication allows to increase redundancy so this scenarios is less likely to happen.
The following scenarios show different trade-offs that could increase the risk of lossing data:</description></item><item><title>Kafka Producer idempotency is enabled by default since 3.0</title><link>https://jeqo.github.io/notes/2021-12-09-kafka-v3-idempotent-acks-all/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2021-12-09-kafka-v3-idempotent-acks-all/</guid><description>Since Apache Kafka 3.0, Producers come with enable.idempotency=true which leads to acks=all, along with other changes enforced by idempotency.
This means by default Producers will be balanced between latency (no batching) and durability — different from previous versions where the main goal was to reduce latency even by risking durability with acks=1.</description></item><item><title>Reducing `acks` doesn't help to reduce end-to-end latency</title><link>https://jeqo.github.io/notes/2021-12-09-kafka-reducing-acks-and-latency/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2021-12-09-kafka-reducing-acks-and-latency/</guid><description>&lt;p>Kafka Producers enforce durability across replicas by setting &lt;code>acks=all&lt;/code> (&lt;a href="https://jeqo.github.io/til/kafka-v3-idea">default since v3.0&lt;/a>).
As enforcing this guarantee requires waiting for replicas to sync, this increases latency; and reducing it tends to give the impression that latency gets reduced overall.&lt;/p></description></item><item><title>Use min.insync.replicas for fault-tolerance</title><link>https://jeqo.github.io/notes/2021-12-02-kafka-min-isr/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2021-12-02-kafka-min-isr/</guid><description>&lt;p>Things to remember:&lt;/p>
&lt;ul>
&lt;li>Topic replication factor is not enough to guarantee fault-tolerance. If &lt;code>min.insync.replicas&lt;/code> is not defined i.e. 1, then data could potentially be lost.&lt;/li>
&lt;li>&lt;code>acks=all&lt;/code> will force replica leader to wait for &lt;em>all&lt;/em> brokers in the ISR, not only the &lt;code>min.insync.replicas&lt;/code>.&lt;/li>
&lt;li>If replicas available are equal to minimum ISR, then the topic partitions are at the edge of losing availability. If one broker becomes unavailable (e.g. restarting), then producers will fail to write data.&lt;/li>
&lt;li>Topic configuration is inherited from the server. If broker configuration changes, it affects the &lt;em>existing&lt;/em> topics. Keep the topic defaults, unless it needs to be different than broker default for easier maintenance.&lt;/li>
&lt;/ul></description></item><item><title>Making sense of Event-Driven Systems @ Oracle Code One 2019</title><link>https://jeqo.github.io/talks/making-sense-event-driven-systems-codeone19/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/talks/making-sense-event-driven-systems-codeone19/</guid><description>&lt;p>Presented at &lt;a href="https://events.rainfocus.com/widget/oracle/oow19/catalogcodeone19?search=jorge&amp;search.codeonetracks=15560568230440086BEm">Oracle Code One 2019&lt;/a>&lt;/p></description></item><item><title>Making sense of Event-Driven Systems @ Kafka Summit 2019</title><link>https://jeqo.github.io/talks/making-sense-event-driven-dataflows-kafkasummitnyc19/</link><pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/talks/making-sense-event-driven-dataflows-kafkasummitnyc19/</guid><description>&lt;p>Presented at &lt;a href="https://kafka-summit.org/sessions/tracing-kafka-based-applications-making-sense-event-driven-dataflows/">Kafka Summit NYC 2019&lt;/a>&lt;/p></description></item><item><title>The Importance of Distributed Tracing for Apache Kafka Based Applications</title><link>https://jeqo.github.io/posts/2019-03-26-importance-of-distributed-tracing-for-apache-kafka-based-applications/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2019-03-26-importance-of-distributed-tracing-for-apache-kafka-based-applications/</guid><description>Originally posted in Confluent Blog
Apache Kafka® based applications stand out for their ability to decouple producers and consumers using an event log as an intermediate layer.
One result of this is that producers and consumers don’t know about each other, as there is no direct communication between them.
This enables choreographed service collaborations, where many components can subscribe to events stored in the event log and react to them asynchronously.</description></item><item><title>The Importance of Observability for Kafka-based applications with Zipkin @ Oslo Apache Kafka Meetup</title><link>https://jeqo.github.io/talks/the-importance-of-observability-kafkausergroupnorway18/</link><pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/talks/the-importance-of-observability-kafkausergroupnorway18/</guid><description>&lt;p>Presented at &lt;a href="https://www.meetup.com/en-AU/Oslo-Kafka/events/254039906/">Oslo Apache Kafka Meetup&lt;/a>&lt;/p></description></item><item><title>Notes on Kafka, Samza and the Unix Philosophy of Distributed Data</title><link>https://jeqo.github.io/notes/2018-07-27-kafka-samza-and-the-unix-philosophy-of-distributed-data/</link><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/notes/2018-07-27-kafka-samza-and-the-unix-philosophy-of-distributed-data/</guid><description>&amp;nbsp;From Batch to Streaming workflows Key properties for large-scale systems:
[Large-Scale Personalized Services] should have the following properties:
System scalability Organizational scalability Operational robustness Where Batch jobs have been successfully used, and represent a reference model to improve from:
[Batch, Map-Reduce jobs] has been remarkably successful tool for implementing recommendation systems.
[Batch important benefits:]
Multi-consumer: several jobs reading input directories without affecting each others. Visibility: job&amp;rsquo;s input and output can be inspected for tracking down the cause of an error.</description></item><item><title>Tracing Kafka applications</title><link>https://jeqo.github.io/posts/2017-09-28-kafka-opentracing/</link><pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2017-09-28-kafka-opentracing/</guid><description>for a more updated version, check https://jeqo.github.io/posts/2019-03-26-importance-of-distributed-tracing-for-apache-kafka-based-applications/
Tracing is one of the hardest time in integration or microservice development: knowing how a request impact your different components, and if your components have behave as expected.
This could be fairly easy if we have monolith where we have one database and with some queries or checking one log file you can validate everything went well.
Once you introduce distributed components and asynchronous communication this starts to get more complex and tedious.</description></item><item><title>From Messaging to Logs with Apache Kafka @ OUGN 2017</title><link>https://jeqo.github.io/talks/from-messaging-to-logs-ougn17/</link><pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/talks/from-messaging-to-logs-ougn17/</guid><description>&lt;p>Presented at &lt;a href="http://ougn.no/varseminar-2017/">OUGN 2017&lt;/a>&lt;/p></description></item><item><title>Rewind Kafka Consumer Offsets</title><link>https://jeqo.github.io/posts/2017-01-31-kafka-rewind-consumers-offset/</link><pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2017-01-31-kafka-rewind-consumers-offset/</guid><description>&lt;p>One of the most important features from &lt;em>Apache Kafka&lt;/em> is how it manages
Multiple Consumers. Each &lt;code>consumer group&lt;/code> has a current &lt;code>offset&lt;/code>, that
determine at what point in a &lt;code>topic&lt;/code> this &lt;code>consumer group&lt;/code> has consume
messages. So, each &lt;code>consumer group&lt;/code> can manage its &lt;code>offset&lt;/code> independently,
by &lt;code>partition&lt;/code>.&lt;/p>
&lt;p>This offers the possibility to rollback in time and reprocess messages from
the beginning of a &lt;code>topic&lt;/code> and regenerate the current status of the system.&lt;/p>
&lt;p>But how to do it (programmatically)?&lt;/p></description></item><item><title>Scaling Kafka with Docker Containers</title><link>https://jeqo.github.io/posts/2017-01-15-scale-kafka-containers/</link><pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2017-01-15-scale-kafka-containers/</guid><description>&lt;p>In this post I will show how to use Docker containers to create and scale
a Kafka cluster, and also how to create, scale and move &lt;code>topics&lt;/code> inside
the cluster.&lt;/p></description></item><item><title>Integrate Java EE 7 and Kafka using Avro and RxJava</title><link>https://jeqo.github.io/posts/2015-07-31-java-ee-rxjava-kafka-avro/</link><pubDate>Fri, 31 Jul 2015 00:00:00 +0000</pubDate><guid>https://jeqo.github.io/posts/2015-07-31-java-ee-rxjava-kafka-avro/</guid><description>&lt;p>I decided to implement a naive integration between Java EE applications and
RxJava/Kafka/Avro, to publish and subscribe to events.&lt;/p>
&lt;p>You can go directly to that &lt;a href="https://github.com/jeqo/java-ee-rxjava-kafka-avro">code&lt;/a>, or check my approach:&lt;/p></description></item></channel></rss>